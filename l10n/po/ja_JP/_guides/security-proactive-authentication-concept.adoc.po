msgid ""
msgstr ""
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: doc-l10n-kit"

#. type: Title =
#: upstream/_guides/security-proactive-authentication-concept.adoc:7
#, no-wrap
msgid "Proactive authentication"
msgstr "プロアクティブ認証"

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:12
msgid "Proactive authentication is enabled in Quarkus by default. This means that if an incoming request has a credential then that request will always be authenticated, even if the target page does not require authentication."
msgstr "Quarkusでは、プロアクティブ認証がデフォルトで有効になっています。つまり、受信リクエストにクレデンシャルがある場合、ターゲットページで認証が必要ない場合でも、そのリクエストは常に認証されることになります。"

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:16
msgid "Requests with an invalid credential will always be rejected, even when the page is public."
msgstr "無効なクレデンシャルを含むリクエストは、ページが公開されている場合でも、常に拒否されます。"

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:18
msgid "You can change the default behavior if you only want to authenticate when the target page requires authentication."
msgstr "対象ページが認証を必要とする場合にのみ認証を行いたい場合は、デフォルトの動作を変更することができます。"

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:20
msgid "To disable proactive authentication in Quarkus, set the following attribute in the `application.properties` configuration file:"
msgstr "Quarkusでプロアクティブ認証を無効にするには、 `application.properties` 設定ファイルで次の属性を設定します:"

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:24
#, no-wrap
msgid "`quarkus.http.auth.proactive=false` \n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:27
msgid "If you disable proactive authentication, the authentication process runs only when an identity is requested. An identity can be requested because of security rules that require the user to authenticate or because programmatic access to the current identity is required."
msgstr "プロアクティブ認証を無効にすると、アイデンティティーが要求されたときにのみ、認証プロセスが実行されます。アイデンティティーが要求されるのは、ユーザーを認証する必要があるセキュリ ティルールールや、現在の アイデンティティーへのプログラムによるアクセスによってです。"

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:33
msgid "If proactive authentication is in use, accessing the `SecurityIdentity` is a blocking operation.  This is because authentication may have yet to happen, and accessing it may require calls to external systems, such as databases that may block.  For blocking applications, this is no problem. However, if you have disabled authentication in a reactive application, this will fail (as you cannot do blocking operations on the IO thread).  To work around this, you need to `@Inject` an instance of `io.quarkus.security.identity.CurrentIdentityAssociation` and call the `Uni<SecurityIdentity> getDeferredIdentity();` method.  You can then subscribe to the resulting `Uni` and will be notified when authentication is complete and the identity is available."
msgstr "プロアクティブ認証が使用されている場合、 `SecurityIdentity` へのアクセスはブロッキング操作となります。これは、認証がまだ行われていない可能性があり、アクセスするとデータベースなどの外部システムへの呼び出しが必要になり、ブロックされる可能性があるためです。ブロッキングアプリケーションの場合、これは問題ではありません。しかし、リアクティブアプリケーションで認証を無効にしている場合、これは失敗します（IOスレッドでブロッキング処理を行うことができないため）。これを回避するには、 `io.quarkus.security.identity.CurrentIdentityAssociation` のインスタンスを `@Inject` して、 `Uni<SecurityIdentity> getDeferredIdentity();` のメソッドを呼び出す必要があります。その後、生成された `Uni` を購読することで、認証が完了し、ID が利用可能になったときに通知されるようになります。"

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:36
msgid "It's still possible to access the `SecurityIdentity` synchronously with `public SecurityIdentity getIdentity()` in the xref:resteasy-reactive.adoc[RESTEasy Reactive] from endpoints annotated with `@RolesAllowed`, `@Authenticated`, or with respective configuration authorization checks as authentication has already happened.  The same is also valid for the xref:reactive-routes.adoc[Reactive routes] if a route response is synchronous."
msgstr "`@RolesAllowed` 、 `@Authenticated` 、またはそれぞれの設定の認可チェックでアノテーションされたエンドポイントから、RESTEasy xref:resteasy-reactive.adoc[Reactive] の `public SecurityIdentity getIdentity()` と同期して `SecurityIdentity` にアクセスすることは、すでに認証が行われているため可能です。また、ルートレスポンスが同期的である場合、 xref:reactive-routes.adoc[Reactiveルート] についても同様です。"

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:39
msgid "xref:security-authorization.adoc#standard-security-annotations[Standard security annotations] on CDI beans are not supported on IO thread if a non-void secured method returns a value synchronously and proactive authentication is disabled, as they need to access the `SecurityIdentity`.  In the example below, we have defined `HelloResource` and `HelloService`. It's easy to see that any GET request to `/hello` will run on IO thread and throw `BlockingOperationNotAllowedException` exception."
msgstr "CDI Beanの xref:security-authorization.adoc#standard-security-annotations[標準セキュリティアノテーション] は、非voidの保護されたメソッドが同期的に値を返し、プロアクティブ認証が無効な場合、IOスレッドではサポートされません。 `SecurityIdentity` にアクセスする必要があるからです。以下の例では、 `HelloResource` と `HelloService` を定義しました。 `/hello` へのGETリクエストはIOスレッドで実行されて `BlockingOperationNotAllowedException` 例外が投げられることが容易にわかります。"

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:41
msgid "There is more than one way to fix the example:"
msgstr "例の修正方法は1つではありません:"

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:43
msgid "switch to a worker thread (annotate `hello` endpoint with `@Blocking`)"
msgstr "ワーカスレッドに切り替える ( `hello` のエンドポイントに `@Blocking` のアノテーションを付ける)"

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:44
msgid "change `sayHello` method return type (use reactive or asynchronous data type)"
msgstr "`sayHello` メソッドの戻り値の型を変更する（リアクティブまたは非同期データ型を使用する）。"

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:45
msgid "arguably the safest way is to move `@RolesAllowed` annotation to the endpoint, as accessing `SecurityIdentity` from endpoint methods is never the blocking operation"
msgstr "エンドポイントメソッドから `SecurityIdentity` へのアクセスはブロック操作にならないため、 `@RolesAllowed` のアノテーションをエンドポイントに移動させるのが最も安全な方法であることは間違いありません。"

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:52
#, no-wrap
msgid ""
"import jakarta.annotation.security.PermitAll;\n"
"import jakarta.inject.Inject;\n"
"import jakarta.ws.rs.GET;\n"
"import jakarta.ws.rs.Path;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:54
#, no-wrap
msgid "import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:58
#, no-wrap
msgid ""
"@Path(\"/hello\")\n"
"@PermitAll\n"
"public class HelloResource {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:61
#, no-wrap
msgid ""
"    @Inject\n"
"    HelloService helloService;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:66
#, no-wrap
msgid ""
"    @GET\n"
"    public Uni<String> hello() {\n"
"        return Uni.createFrom().item(helloService.sayHello());\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:68
#: upstream/_guides/security-proactive-authentication-concept.adoc:84
#, no-wrap
msgid "}\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:74
#, no-wrap
msgid ""
"import jakarta.annotation.security.RolesAllowed;\n"
"import jakarta.enterprise.context.ApplicationScoped;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:77
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class HelloService {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:82
#, no-wrap
msgid ""
"    @RolesAllowed(\"admin\")\n"
"    public String sayHello() {\n"
"        return \"Hello\";\n"
"    }\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/security-proactive-authentication-concept.adoc:86
#, no-wrap
msgid "How to customize authentication exception responses"
msgstr "認証の例外応答をカスタマイズする方法"

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:89
msgid "You can use Jakarta REST `ExceptionMapper` to capture Quarkus Security authentication exceptions such as `io.quarkus.security.AuthenticationFailedException`, for example:"
msgstr "Jakarta REST `ExceptionMapper` を使用して、例えば `io.quarkus.security.AuthenticationFailedException` のような Quarkus Security の認証例外を捕捉することができます:"

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:93
#: upstream/_guides/security-proactive-authentication-concept.adoc:125
#, no-wrap
msgid "package io.quarkus.it.keycloak;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:99
#, no-wrap
msgid ""
"import jakarta.annotation.Priority;\n"
"import jakarta.ws.rs.Priorities;\n"
"import jakarta.ws.rs.core.Response;\n"
"import jakarta.ws.rs.ext.ExceptionMapper;\n"
"import jakarta.ws.rs.ext.Provider;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:101
#, no-wrap
msgid "import io.quarkus.security.AuthenticationFailedException;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:105
#, no-wrap
msgid ""
"@Provider\n"
"@Priority(Priorities.AUTHENTICATION)\n"
"public class AuthenticationFailedExceptionMapper implements ExceptionMapper<AuthenticationFailedException> {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:108
#, no-wrap
msgid ""
"    @Context\n"
"    UriInfo uriInfo;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:114
#, no-wrap
msgid ""
"    @Override\n"
"    public Response toResponse(AuthenticationFailedException exception) {\n"
"        return Response.status(401).header(\"WWW-Authenticate\", \"Basic realm=\\\"Quarkus\\\"\").build();\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:121
msgid "Some HTTP authentication mechanisms need to handle authentication exceptions themselves to create a correct authentication challenge.  For example, `io.quarkus.oidc.runtime.CodeAuthenticationMechanism` which manages OpenId Connect authorization code flow authentication, needs to build a correct redirect URL, cookies, etc.  For that reason, using custom exception mappers to customize authentication exceptions thrown by such mechanisms is not recommended.  Instead, a safer approach would be to ensure that proactive authentication is enabled and to use Vert.x HTTP route failure handlers. This is because events come to the handler with the correct response status and headers.  You will then only need to customize the response, as outlined in the following example:"
msgstr "HTTP認証メカニズムの中には、正しい認証チャレンジを作成するために、認証例外を自ら処理する必要があるものがあります。例えば、OpenID Connectの認可コードフロー認証を管理する `io.quarkus.oidc.runtime.CodeAuthenticationMechanism` 、正しいリダイレクトURLやCookieなどを構築する必要があります。そのため、このような認証メカニズムが投げる認証例外をカスタマイズするために、カスタム例外マッパーを使用することは推奨されません。代わりに、プロアクティブ認証が有効になっていることを確認し、Vert.x HTTPルート失敗ハンドラを使用することが、より安全なアプローチとなるでしょう。これは、イベントが正しい応答ステータスとヘッダーでハンドラーに来るからです。その後、次の例で説明するように、レスポンスをカスタマイズするだけでよいでしょう:"

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:128
#, no-wrap
msgid ""
"import jakarta.enterprise.context.ApplicationScoped;\n"
"import jakarta.enterprise.event.Observes;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:133
#, no-wrap
msgid ""
"import io.quarkus.security.AuthenticationFailedException;\n"
"import io.vertx.core.Handler;\n"
"import io.vertx.ext.web.Router;\n"
"import io.vertx.ext.web.RoutingContext;\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:136
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class AuthenticationFailedExceptionHandler {\n"
msgstr ""

#. type: delimited block -
#: upstream/_guides/security-proactive-authentication-concept.adoc:150
#, no-wrap
msgid ""
"    public void init(@Observes Router router) {\n"
"        router.route().failureHandler(new Handler<RoutingContext>() {\n"
"            @Override\n"
"            public void handle(RoutingContext event) {\n"
"                if (event.failure() instanceof AuthenticationFailedException) {\n"
"                    event.response().end(\"CUSTOMIZED_RESPONSE\");\n"
"                } else {\n"
"                    event.next();\n"
"                }\n"
"            }\n"
"        });\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_guides/security-proactive-authentication-concept.adoc:152
#, no-wrap
msgid "References"
msgstr "参照"

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:155
msgid "xref:security-overview-concept.adoc[Quarkus Security overview]"
msgstr "xref:security-overview-concept.adoc[Quarkus Security 概要]"

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:156
msgid "xref:security-architecture-concept.adoc[Quarkus Security architecture]"
msgstr "xref:security-architecture-concept.adoc[Quarkus Security アーキテクチャー]"

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:157
msgid "xref:security-authentication-mechanisms-concept.adoc#other-supported-authentication-mechanisms[Authentication mechanisms in Quarkus]"
msgstr "xref:security-authentication-mechanisms-concept.adoc#other-supported-authentication-mechanisms[Quarkusの認証メカニズム]"

#. type: Plain text
#: upstream/_guides/security-proactive-authentication-concept.adoc:157
msgid "xref:security-identity-providers-concept.adoc[Identity providers]"
msgstr "xref:security-identity-providers-concept.adoc[アイデンティティ・プロバイダー]"

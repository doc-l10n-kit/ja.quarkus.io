msgid ""
msgstr ""
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: doc-l10n-kit"

#. type: YAML Front Matter
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:2
msgid "post"
msgstr "post"

#. type: YAML Front Matter
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:3
#, fuzzy
msgid "Ideas on Quarkus command-mode, UI-based apps and releasing via GitHub Actions"
msgstr "Quarkusのコマンドモード、UIベースのアプリ、GitHub Actions経由でのリリースに関するアイデア。"

#. type: YAML Front Matter
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:4
#, fuzzy
msgid "2020-05-12"
msgstr "2020-05-12"

#. type: YAML Front Matter
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:5
#, fuzzy
msgid "development-tips"
msgstr "開発秘話"

#. type: YAML Front Matter
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:6
#, fuzzy
msgid "Ideas on how to use Quarkus command-mode to develop native applications with web frontends; built with GitHub Actions."
msgstr "Quarkusのコマンドモードを使用して、Webフロントエンドを持つネイティブアプリケーションを開発する方法について、GitHub Actionsを使用して構築しました。"

#. type: YAML Front Matter
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:7
#, fuzzy
msgid "dplatz"
msgstr "大道芸人"

#. type: Plain Text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:11
#, fuzzy
msgid "Quarkus is advertised as a cloud-native runtime for Microservices but the link:https://quarkus.io/blog/quarkus-1-4-final-released/[introduction of command-mode] might have opened up new and interesting spaces where it could find adoption."
msgstr "QuarkusはMicroservicesのためのクラウドネイティブランタイムとして宣伝されていますが、 link:https://quarkus.io/blog/quarkus-1-4-final-released/[コマンドモードの導入により] 、新しい興味深い空間が広がり、採用されるかもしれません。"

#. type: Plain Text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:13
#, fuzzy
msgid ""
"In this blog post I will present a few ideas about the possible usage of command-mode in Quarkus that you might find useful to consider when developing your next tool.\n"
"If you have not heard about command-mode, I suggest to start reading link:https://quarkus.io/blog/introducing-command-mode/[this introduction] first and then come back."
msgstr "このブログ記事では、Quarkusにおけるコマンドモードの可能な使用方法について、次のツールを開発する際に考慮すると便利だと思われるアイデアをいくつか紹介します。コマンドモードについて知らない場合は、まず link:https://quarkus.io/blog/introducing-command-mode/[この紹介を] 読んでから、また戻ってくることをお勧めします。"

#. type: Plain Text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:16
#, fuzzy
msgid "Ready? Ok, let's continue."
msgstr "準備はいいですか？よし、続けよう。"

#. type: Title ==
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:18
#, fuzzy
msgid "Cross-platform builds via GitHub Actions"
msgstr "GitHub Actionsを利用したクロスプラットフォームビルド。"

#. type: Plain Text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:20
#, fuzzy
msgid ""
"Command-line tools like `kubectl` are often written in languages like C, Go or Rust and compiled to native executables for various target platforms.\n"
"This is great because you don't need to rely on Java installed; or being installed in a wrong version."
msgstr "`kubectl` のようなコマンドラインツールは、C、Go、Rust などの言語で書かれ、さまざまなターゲットプラットフォーム用のネイティブ実行ファイルにコンパイルされることが多いです。これは、インストールされたJavaに依存する必要がない、あるいは間違ったバージョンでインストールされることがない、という点で優れています。"

#. type: Plain Text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:23
#, fuzzy
msgid ""
"With GraalVM native-images, this argument against Java does not hold anymore. Quarkus supports the build of native executables via GraalVM; mainly for building natively for Linux containers but there is experimental support for OS X and Windows as well.\n"
"Using the native build in combination with command-mode sounds like a very interesting and productive choice to write command-line tools."
msgstr "GraalVMのネイティブイメージでは、このJavaに対する議論はもう成り立ちません。Quarkusは、GraalVMを介したネイティブ実行ファイルのビルドをサポートしています。主にLinuxコンテナのネイティブビルドのためのものですが、OS XとWindowsについても実験的サポートがあります。ネイティブビルドとコマンドモードの組み合わせは、コマンドラインツールを書く上で非常に興味深く、生産的な選択肢のように思えます。"

#. type: Plain Text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:26
#, fuzzy
msgid ""
"But how do you build your native executables for Linux, Mac and Windows?\n"
"If you are hosting your sources as a GitHub project, I can tell you that it is super-simple to get started. GitHub offers link:https://help.github.com/en/actions/building-and-testing-code-with-continuous-integration/setting-up-continuous-integration-using-github-actions[ Actions] which is a free service like link:https://travis-ci.org/[Travis CI] but fully integrated into the GitHub experience. Also, it offers runners (i.e. the build agents) for Linux, Mac and Windows."
msgstr "しかし、Linux、Mac、Windows用のネイティブ実行可能ファイルをどのように構築するのでしょうか？もしあなたがソースをGitHubプロジェクトとしてホスティングしているのであれば、超簡単に始めることができると思います。GitHubは link:https://help.github.com/en/actions/building-and-testing-code-with-continuous-integration/setting-up-continuous-integration-using-github-actions[Actionsを] 提供しています。これは link:https://travis-ci.org/[Travis CIと] 同じような無料サービスですが、GitHubの体験に完全に統合されています。また、Linux、Mac、Windows用のランナー（つまりビルドエージェント）も提供されています。"

#. type: Plain Text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:29
#, fuzzy
msgid "To provide a native release-build for linux, place the following file under `.github/workflows` in your repo:"
msgstr "linuxのネイティブリリースビルドを提供するには、以下のファイルをリポジトリの `.github/workflows` の下に置きます："

#. type: Plain Text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:67
#, fuzzy
msgid "This build-job is triggered when a new release is triggered. If your are the owner, you will have the button \"Draft a new release\" under link:https://github.com/38leinaD/quarkus-native-app-starter/releases[releases]"
msgstr "このビルドジョブは、新しいリリースがトリガーされたときに起動されます。あなたがオーナーであれば、 link:https://github.com/38leinaD/quarkus-native-app-starter/releases[リリースの] 下に「新しいリリースを作成する」というボタンが表示されます。"

#. type: Plain Text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:68
#, fuzzy
msgid "Uses a ubuntu runner. See link:https://github.com/actions/virtual-environments[GitHub Actions Virtual Environments] for a list of all supported environments/runners."
msgstr "ubuntuのランナーを使用します。サポートされている環境/ランナーの一覧は、 link:https://github.com/actions/virtual-environments[GitHub Actions Virtual Environmentsを] 参照してください。"

#. type: Plain Text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:69
#, fuzzy
msgid "Set version in `pom.xml` based on specified release version"
msgstr "指定されたリリースバージョンに基づき、 `pom.xml` 、バージョンを設定する。"

#. type: Plain Text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:70
#, fuzzy
msgid "Build the native executable"
msgstr "ネイティブ実行可能ファイルのビルド"

#. type: Plain Text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:71
#, fuzzy
msgid "Upload/attach the artifact to the release"
msgstr "アーティファクトをリリースにアップロード/添付する"

#. type: Plain Text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:73
#, fuzzy
msgid "Building for Mac just means to provide another job with `runs-on: macos-latest`."
msgstr "Mac 用のビルドは、 `runs-on: macos-latest` で別の仕事を提供することを意味するだけです。"

#. type: Plain Text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:75
#, fuzzy
msgid ""
"Windows is essentially the same but requires a little more attention and knowledge about the tooling. Getting it working required some investigation on how the native build depends on Visual Studio. Also,the Windows runners on GitHub Actions have a too small page-file by default. That needs increasing as the memory consumption is rather high when running the GraalVMs `native-image` command.\n"
"An full example of a working native-image build under windows can be found link:https://github.com/38leinaD/quarkus-native-app-starter/blob/master/.github/workflows/release-build-native-win64.yml[here]."
msgstr "Windowsも基本的には同じですが、ツールについてもう少し注意と知識が必要です。ネイティブビルドがVisual Studioにどのように依存しているのかを調査する必要がありました。また、GitHub ActionsのWindowsランナーは、デフォルトでページファイルが小さすぎる。GraalVMs `native-image` コマンドを実行するときにメモリ消費がかなり大きいので、これを増やす必要があります。Windowsで動作するネイティブイメージビルドの全例は、 link:https://github.com/38leinaD/quarkus-native-app-starter/blob/master/.github/workflows/release-build-native-win64.yml[ここに] あります。"

#. type: Plain Text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:78
#, fuzzy
msgid "After triggering a release from the GitHub UI, the jobs for all target environments are triggered. The artifacts for all platforms are will be available within minutes and can be consumed by your users. Building, hosting: 100% free and no external service or registration needed."
msgstr "GitHub UIからリリースをトリガーすると、すべてのターゲット環境に対するジョブがトリガーされます。すべてのプラットフォームのアーティファクトは数分以内に利用可能になり、ユーザーが消費することができるようになります。構築、ホスティング：100%無料で、外部サービスや登録は必要ありません。"

#. type: Plain Text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:80
#, fuzzy
msgid "image:github-actions.jpg[]"
msgstr "image:github-actions.jpg[alt=\"github actions\"]"

#. type: Title ==
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:82
#, fuzzy
msgid "Command-mode for UI-based applications"
msgstr "UIベースのアプリケーションのためのコマンドモード"

#. type: Plain Text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:84
#, fuzzy
msgid ""
"Another exciting thing about command-mode is that it not only allows to write nice command-line tools (using e.g. link:https://picocli.info/[Picocli], link:http://aeshell.github.io/[Aesh] or link:https://commons.apache.org/proper/commons-cli/[Apache Commons CLI]) but in general allows to have more control over the lifecycle of an application.\n"
"With the possibility to embed your HTML/Javascript frontend, we can even build link:https://www.electronjs.org/[Electron-style] desktop application with rich user interfaces for our tools. As even JSF most likely will be link:https://github.com/adminfaces/quarkus-admin-starter[coming to Quarkus], there is a great variety of choices on how to build a frontend."
msgstr "コマンドモードのもう一つの魅力は、 link:https://picocli.info/[Picocliや] link:http://aeshell.github.io/[Aesh] 、 link:https://commons.apache.org/proper/commons-cli/[Apache Commons CLIなどの] コマンドラインツールを書くことができるだけでなく、アプリケーションのライフサイクルをよりコントロールできるようになることでしょう。HTML/Javascriptのフロントエンドを埋め込むことができるので、 link:https://www.electronjs.org/[Electronスタイルの] デスクトップアプリケーションを構築して、リッチなユーザーインターフェイスを持つツールを作ることも可能です。 link:https://github.com/adminfaces/quarkus-admin-starter[Quarkusには] JSFも導入される可能性が高いので、フロントエンドを構築する方法には非常に多様な選択肢があります。"

#. type: Plain Text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:87
#, fuzzy
msgid ""
"A very simple scaffold does not require much. If you have `quarkus-resteasy` as a dependency, the embedded server will be started on port `8080` just like in any regular Quarkus backend application.\n"
"As your tools might be running on a developer system alongside other app-servers or Quarkus instances, it is a good idea to choose a different port to not run into conflicts."
msgstr "非常にシンプルな雛形であれば、それほど多くのことを必要としません。依存関係として `quarkus-resteasy` を指定すると、通常のQuarkusバックエンドアプリケーションと同様に、埋め込みサーバーはポート `8080` で起動されます。ツールは、他のアプリサーバーやQuarkusインスタンスと一緒に開発者システムで実行される可能性があるため、競合が発生しないよう、別のポートを選択することをお勧めします。"

#. type: Plain Text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:90
#, fuzzy
msgid ""
"Configuring `quarkus.http.port=0` in your `application.properties` will make Quarkus choose a random but free port.\n"
"How to know from within your application which port it is? When injecting the config-property via `@ConfigProperty(name = \"quarkus.http.port\")`, you will get the assigned port."
msgstr "`application.properties` で `quarkus.http.port=0` を設定すると、Quarkusはランダムだが空いているポートを選択するようになります。アプリケーション内でポートを確認するにはどうすればよいですか？ `@ConfigProperty(name = \"quarkus.http.port\")` を介して config-property を注入すると、割り当てられたポートが表示されます。"

#. type: Plain Text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:93
#, fuzzy
msgid "Assuming you have your front-end under `src/main/resources/META-INF/resources` (in my example it is plain HTML with Javascript) and using a very old Java API (`Desktop.getDesktop().browse(...)`), you can spin up the default browser to your app like this:"
msgstr "フロントエンドを `src/main/resources/META-INF/resources` の下に置き（私の例では、Javascriptを使ったプレーンなHTMLです）、非常に古いJava API ( `Desktop.getDesktop().browse(…​)` ) を使っていると仮定すると、次のようにアプリのデフォルトブラウザをスピンアップすることができます："

#. type: Plain Text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:125
#, fuzzy
msgid "Get the assigned port"
msgstr "割り当てられたポートを取得する"

#. type: Plain Text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:126
#, fuzzy
msgid "Open the `index.html` of your webapp with the default browser."
msgstr "デフォルトのブラウザで、Webアプリの `index.html` を開きます。"

#. type: Plain Text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:127
#, fuzzy
msgid "Do not exit immediately but wait until the browser/tab is closed. See below for options how to do this."
msgstr "すぐに終了せず、ブラウザやタブが閉じるまで待ちます。この方法については、以下を参照してください。"

#. type: Plain Text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:129
#, fuzzy
msgid "There are some more considerations here to make it work reliably."
msgstr "確実に動作させるためには、ここにもいくつかの配慮が必要です。"

#. type: Plain Text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:131
#, fuzzy
msgid ""
"Ending the application when the browser window closes requires some feedback. There are simple ways to achieve this in a semi-reliabe way (see the usage of link:https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event[unload] in link:https://github.com/38leinaD/quarkus-native-app-starter/blob/master/src/main/resources/META-INF/resources/index.html#L89[index.html] by calling link:https://github.com/38leinaD/quarkus-native-app-starter/blob/master/src/main/java/org/acme/LsResource.java#L38[a rest endpoint]).\n"
"For Desktop-class applications, one might have to control the browser process more closely; or, like Electron, even package an own version of Chrome."
msgstr "ブラウザのウィンドウが閉じたときにアプリケーションを終了させるには、何らかのフィードバックが必要です。これを半信半疑で実現する簡単な方法があります（ link:https://github.com/38leinaD/quarkus-native-app-starter/blob/master/src/main/java/org/acme/LsResource.java#L38[restエンド] ポイントを呼び出して link:https://github.com/38leinaD/quarkus-native-app-starter/blob/master/src/main/resources/META-INF/resources/index.html#L89[index.htmlの] link:https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event[unloadを] 利用する方法を参照ください）。Desktopクラスのアプリケーションでは、ブラウザのプロセスをより厳密に制御する必要があるかもしれません。Electronのように、独自のバージョンのChromeをパッケージ化することもできます。"

#. type: Plain Text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:134
#, fuzzy
msgid "A problem I was facing is that `Desktop.getDesktop().browse(...)` does not seem to work reliably when run in native mode with the GraalVM version I was using (link:https://github.com/oracle/graal/issues/2430[issue]). The alternative, like already stated before, is to control the browser more directly and for example open a Chrome window via link:https://docs.oracle.com/javase/7/docs/api/java/lang/Runtime.html#exec(java.lang.String)[Runtime.exec(...)]. See the link:https://github.com/38leinaD/quarkus-native-app-starter/blob/master/src/main/java/org/acme/LsMain.java[main method] of the starter project for some possibilities to experiment with."
msgstr "私が直面していた問題は、私が使用していたGraalVMのバージョン（ link:https://github.com/oracle/graal/issues/2430[問題] ）でネイティブモードで実行すると、 `Desktop.getDesktop().browse(…​)` が確実に動作しないようだということです。代替案は、すでに述べたように、より直接的にブラウザを制御し、例えば link:https://docs.oracle.com/javase/7/docs/api/java/lang/Runtime.html#exec(java.lang.String)[Runtime.exec(...)] を介してChromeウィンドウを開くことです。スタータープロジェクトの link:https://github.com/38leinaD/quarkus-native-app-starter/blob/master/src/main/java/org/acme/LsMain.java[メインメソッドで] 、いくつかの可能性を試してみてください。"

#. type: Plain Text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:136
#, fuzzy
msgid "image:quarkus-native-webui.gif[]"
msgstr "image:quarkus-native-webui.gif[alt=\"quarkus native webui\"]"

#. type: Title ==
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:138
msgid "Summary"
msgstr "まとめ"

#. type: Plain Text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:140
#, fuzzy
msgid ""
"It will be interesting to see where people are taking command-mode. Maybe we will be seeing Electron-style Desktop applications being developed based on Quarkus?\n"
"At least to me, this sounds promising and productive. No wasting of time to learn a completely different stack just to write a small tool. Instead, use the same stack and API I am familar with from backend development anyway."
msgstr "人々がコマンドモードをどこに持っていくのか、興味深いところです。もしかしたら、QuarkusをベースにしたElectronスタイルのデスクトップアプリケーションが開発されるようになるかもしれません。少なくとも私には、これは有望で生産的だと思います。小さなツールを書くために、まったく別のスタックを学ぶという時間の無駄はありません。その代わり、バックエンド開発で慣れ親しんだ同じスタックとAPIを使えばいいのです。"

#. type: Plain Text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:143
#, fuzzy
msgid "We have seen that making a tool available in a way that is easy to consume by people can be achived with GitHub and GitHub Actions alone."
msgstr "GitHubとGitHub Actionsだけで、ツールを人々が利用しやすい形で提供することができることを確認してきました。"

#. type: Plain Text
#: upstream/_posts/2020-05-12-native-command-mode-tools.adoc:145
#, fuzzy
msgid "In case you are interested in a more complete tool where I have used the ideas presented here, check out my link:https://github.com/38leinaD/bpmn-diff[bpmn-diff] project which is a Git difftool for BPMN files. As an added benefit, it uses Gradle as opposed to Maven and thus provides additional examples on the use of GitHub Actions."
msgstr "ここで紹介したアイデアを使った、より完全なツールに興味がある方は、 link:https://github.com/38leinaD/bpmn-diff[BPMN] ファイルのGit difftoolである私の link:https://github.com/38leinaD/bpmn-diff[bpmn-diff] プロジェクトをチェックしてみてください。さらに、このプロジェクトではMavenではなくGradleを使用しているため、GitHub Actionsの使用に関する追加の例を提供しています。"

msgid ""
msgstr ""
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: jekyll-l10n\n"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Project Leyden"
msgstr "プロジェクト・ライデン"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Project Leyden: exploring its potential for Quarkus users."
msgstr "Project Leyden：Quarkusユーザーにとっての可能性を探るものです。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "You might have heard of https://openjdk.org/projects/leyden/[Project Leyden], an initiative within the OpenJDK project with ambitious goals."
msgstr "link:https://openjdk.org/projects/leyden/[プロジェクト・ライデン（Project Leyden] ）は、野心的な目標を掲げたOpenJDKプロジェクト内のイニシアチブです。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "As Quarkus users, you'll be wondering how this project will benefit you and how it's different from GraalVM native images. While we think it's fair to say that Leyden was inspired or at least motivated by some ideas first implemented in GraalVM's native images, Leyden is remarkably different. It's essential to understand how it works: as we will see, Leyden is not a replacement for GraalVM native images but rather a substantial evolution of the JVM, and we expect it to bring some benefits to native images as well."
msgstr "Quarkusのユーザーであれば、このプロジェクトがどのようなメリットをもたらすのか、またGraalVMのネイティブイメージとどのように異なるのか、気になるところでしょう。私たちは、LeydenがGraalVMのネイティブイメージで最初に実装されたいくつかのアイデアに触発された、あるいは少なくともそれに動かされたと言って差し支えないと思いますが、Leydenは著しく異なっています。これから見るように、LeydenはGraalVMネイティブ・イメージの代替ではなく、むしろJVMの実質的な進化であり、ネイティブ・イメージにもいくつかの利点をもたらすと期待しています。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "To try to clarify this, unfortunately, this post is unusually long: we wish it could have been a short guide, \"This is how you enable Leyden,\" but this isn't quite the time yet, as we need to understand the different models first. Sometimes, the terminology is also different; for example, \"Ahead of Time (AOT)\" has a very specific meaning in the context of GraalVM native images and has traditionally been associated with \"compilation\", but in the context of Leyden is used more broadly to indicate a variety of aspects of JVM operation; hopefully, after reading this, it will be less confusing."
msgstr "これを明確にしようとすると、残念ながら、この投稿は異常に長くなってしまいます。「Leydenを有効にする方法はこうです」という短いガイドにできればよかったのですが、まずは異なるモデルを理解する必要があるため、今はまだその時期ではありません。例えば、\"Ahead of Time (AOT) \"は、GraalVMネイティブ・イメージの文脈では非常に特殊な意味を持ち、伝統的に \"コンパイル \"と関連付けられてきましたが、Leydenの文脈では、JVM操作の様々な側面を示すためにより広く使用されています。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Another significant misconception about Leyden is that it's a project to \"improve startup times\"; this statement is not wrong, as improving startup times is one of its goals. Yet the other stated goals of the project offer even more significant potential for our favourite platform, Quarkus, and its users."
msgstr "Leydenに関するもう一つの重要な誤解は、Leydenが「起動時間を改善する」ためのプロジェクトであるということです。しかし、このプロジェクトが掲げている他の目標は、私たちのお気に入りのプラットフォームであるQuarkusとそのユーザーにとって、さらに大きな可能性を秘めています。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "So, let's dive in."
msgstr "では、飛び込みましょう。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "What is Leyden?"
msgstr "ライデンとは？"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Project Leyden is an initiative from the OpenJDK team. It is an ongoing experiment that is currently being developed by the joint effort of teams from different companies contributing to the project."
msgstr "Project LeydenはOpenJDKチームのイニシアチブです。現在進行中の試みで、プロジェクトに貢献しているさまざまな企業のチームが共同で開発を進めています。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The primary goal of this Project is to improve the startup time, time to peak performance, and footprint of Java programs."
msgstr "このプロジェクトの主な目標は、Javaプログラムの起動時間、ピーク性能までの時間、およびフットプリントを改善することです。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "-- Project Leyden, first thing on its project page"
msgstr "- プロジェクト・ライデン、そのプロジェクト・ページでの第一声"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"Leyden is a general umbrella project to address slow startup and large footprint. It is useful to keep JDK bootstrap times and footprint low. This helps reduce energy consumption, hardware resource use, and, ultimately, monetary costs.\n"
"However, it's equally as essential to reduce the time to application peak performance, time usually spent loading application classes and executing application code, including JIT compiling methods on hot code paths. Reducing application footprint can have a tremendous impact and this can be achieved by trimming not just application data but also application classes and code. Leyden is addressing ways that the JVM can help developers achieve those goals; in many ways, this is complementary to the techniques offered by Quarkus at the framework level, so we expect some powerful results from them combined."
msgstr "Leydenは、起動の遅さとフットプリントの大きさに対処するための包括的なプロジェクトです。JDKの起動時間とフットプリントを低く保つことは有用です。これはエネルギー消費、ハードウェア・リソースの使用、ひいては金銭的コストの削減に役立ちます。しかし、アプリケーションのピーク・パフォーマンスまでの時間、つまりアプリケーション・クラスのロードや、ホット・コード・パスでのJITコンパイル・メソッドを含むアプリケーション・コードの実行に通常費やされる時間を短縮することも、同様に不可欠です。アプリケーションのフットプリントを削減することは非常に大きな効果をもたらしますが、これはアプリケーションデータだけでなく、アプリケーションクラスやコードも削減することで実現できます。Leydenは、JVMが開発者がこれらの目標を達成するのを支援する方法に取り組んでいます。多くの点で、これはQuarkusがフレームワークレベルで提供する技術を補完するものであり、これらを組み合わせることで強力な結果が得られると期待しています。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Note that the project is evolving rapidly: some of the things explained in this article are evolving while this is written. If you plan on getting involved at a more technical level, follow the development in Jira and the https://mail.openjdk.org/mailman/listinfo/leyden-dev[Leyden mailing list]."
msgstr "プロジェクトは急速に進化していることに注意してください：この記事で説明されていることのいくつかは、これが書かれている間にも進化しています。もしあなたがより技術的なレベルで関わるつもりなら、Jiraや link:https://mail.openjdk.org/mailman/listinfo/leyden-dev[Leydenメーリングリストの] 開発をフォローしてください。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Why it’s interesting to Quarkus"
msgstr "クアルカスにとって興味深い理由"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"From a Quarkus perspective, we've done a fair job on all such metrics but we're constantly on the lookout to improve.\n"
"That's why Project Leyden got our attention. We're already working with our colleagues from the OpenJDK team at Red Hat, who are directly involved in implementing Leyden with the wider OpenJDK group: this blog post today is a collaboration among engineers from different teams."
msgstr "Quarkusの観点からすると、私たちはこのような指標すべてにおいてまずまずの成果を上げていますが、常に改善を求めています。だからこそ、Project Leydenは私たちの注目を集めたのです。私たちはすでにRed HatのOpenJDKチームの同僚と協力しており、彼らはより広いOpenJDKグループとともにLeydenの実装に直接関わっています。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Although Quarkus is already doing a lot of work during the Ahead of Time phase to speed up warmup and response time, the enhancements that Leyden brings to the table are more related to how the JVM behaves. Complementing both approaches, the advantages we can expect from the combination of Quarkus and Leyden are beyond anything you can find with either of them in isolation."
msgstr "Quarkusは、ウォームアップとレスポンスタイムを高速化するために、Ahead of Timeフェーズですでに多くの作業を行っていますが、Leydenがテーブルにもたらす機能強化は、JVMの動作により関連しています。両方のアプローチを補完し、QuarkusとLeydenの組み合わせから期待できる利点は、どちらか一方を単独で使用した場合に見出せる以上のものです。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Since the potential for such technological collaboration is strong, the Quarkus and OpenJDK teams are working together on various prototypes and anyone in the community is welcome to join as well."
msgstr "QuarkusとOpenJDKの両チームは、さまざまなプロトタイプを共同開発しています。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Refresher on JVM's bootstrap process"
msgstr "JVMのブートストラップ・プロセスの再確認"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"To better understand the scope of the potential improvements, we need to take a step back and discuss how the JVM works today, especially how our application is started and iteratively evolves from interpreting our bytecode to its highest performance mode: running native code which is highly optimized, adapted to the particular hardware, the configuration of the day, and the specific workloads it's been asked to perform.\n"
"No other runtime is able to match the JVM on this."
msgstr "潜在的な改善の範囲をよりよく理解するためには、一歩下がって、JVMが今日どのように動作しているかを議論する必要があります。特に、アプリケーションがどのように開始され、バイトコードの解釈から最高のパフォーマンス・モードへと反復的に進化するかについてです。この点でJVMに匹敵するランタイムは他にありません。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"As we all know, a Java runtime does not directly run Java source code. The content of our JAR file is not executable machine code, but Java bytecode generated from Java source code, typically using the javac compiler but in some cases Quarkus will emit directly generated bytecode.\n"
"A key feature of bytecode is portability, encoding the structure of Java classes and operation of their methods in a machine and operating-system independent format. A Java runtime obeys the type information in the bytecode when laying out Java objects. Execution of a method normally involves interpreting the operations in the method bytecode, although a runtime may also choose to compile method bytecode to equivalent, native machine code and execute the latter directly."
msgstr "ご存知のように、JavaランタイムはJavaソースコードを直接実行しません。JARファイルの中身は実行可能なマシンコードではなく、Javaソースコードから生成されたJavaバイトコードです。通常はjavacコンパイラを使用しますが、Quarkusが直接生成したバイトコードを出力する場合もあります。バイトコードの主な特徴は移植性で、マシンやオペレーティング・システムに依存しない形式でJavaクラスの構造とメソッドの操作をエンコードします。Javaランタイムは、Javaオブジェクトをレイアウトするとき、バイトコードの型情報に従います。メソッドの実行は通常、メソッド・バイトコード内の操作を解釈することを含みますが、ランタイムはメソッド・バイトコードを同等のネイティブ・マシン・コードにコンパイルし、後者を直接実行することもできます。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The unit of delivery for bytecode is a class file, which models a single class. The Java runtime itself provides a host of utility and runtime management classes, as class files embedded in either system jars or jmod files. Applications supplement this with their own class files, usually by appending jars to the classpath or module path."
msgstr "バイトコードの配信単位はクラス・ファイルで、1つのクラスをモデル化します。Javaランタイム自体は、システムjarまたはjmodファイルに埋め込まれたクラスファイルとして、ユーティリティとランタイム管理クラスのホストを提供します。アプリケーションは、通常クラスパスまたはモジュールパスにjarを追加することによって、独自のクラスファイルでこれを補足します。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Bytecode is delivered class-at-a-time to allow the runtime to load classes _lazily_: i.e. the runtime will only lookup, verify and consume a class file when that class's definition is required to proceed with execution."
msgstr "つまり、ランタイムは、実行を続行するためにクラスの定義が必要な場合にのみ、クラス・ファイルを検索、検証、消費します。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Lazy loading is what allows Java to be a dynamic language -- i.e. one where the code that is included in the program can be decided at runtime. That might include loading classes from jars identified at runtime, possibly loaded via the network. Alternatively, it might include generating class bytecode at runtime, as is done with proxy classes or service provider auxiliary classes."
msgstr "レイジー・ローディングは、Javaが動的言語であること、つまりプログラムに含まれるコードを実行時に決定できることを可能にするものです。これには、実行時に特定されたjarからクラスをロードすることが含まれます。あるいは、プロキシ・クラスやサービス・プロバイダの補助クラスで行われるように、実行時にクラス・バイトコードを生成することも含まれます。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Just in Time (JIT) and Ahead of Time (AOT)"
msgstr "ジャスト・イン・タイム（JIT）とアヘッド・オブ・タイム（AOT）"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"Another name to describe Java's lazy loading is 'Just in Time' (JIT). JIT is a well known term used to describe the operation of Java's runtime compilers. What is less well known is that it has a much wider use.\n"
"JIT is not limited to compilation: many other operations performed by the JVM are done lazily at runtime or 'Just In Time'."
msgstr "Javaの遅延ローディングを表す別の名前は、「ジャスト・イン・タイム」（JIT）です。JITは、Javaのランタイム・コンパイラの動作を表す用語としてよく知られています。あまり知られていないのは、JITにはもっと広い用途があるということです。JITはコンパイルに限定されません。JVMによって実行される他の多くの操作は、ランタイムまたは「ジャスト・イン・タイム」で遅延的に行われます。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"An alternative to doing things 'Just in Time' (JIT) is to do them 'Ahead Of Time' (AOT).\n"
"For example, GraalVM's Native Image runtime loads and analyses the bytecode of every single class needed by an application, including JDK runtime classes, 'Ahead Of Time' i.e. at image build time. It uses the type and method information encoded in that bytecode to 'Ahead Of Time' compile a complete program that includes code for every method that might possibly be executed by the application."
msgstr "ジャスト・イン・タイム（JIT）\"に代わる方法として、\"アヘッド・オブ・タイム（AOT）\"があります。例えば、GraalVMのネイティブ・イメージ・ランタイムは、JDKのランタイム・クラスを含む、アプリケーションに必要なすべてのクラスのバイトコードを「Ahead Of Time」すなわちイメージのビルド時にロードして分析します。そのバイトコードにエンコードされた型とメソッドの情報を使用して、アプリケーションで実行される可能性のあるすべてのメソッドのコードを含む完全なプログラムを「先行して」コンパイルします。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"The approach of GraalVM's native images lies at one extreme: everything is done AOT, while the traditional Java runtime model lies at the other extreme, as much as possible is done JIT.\n"
"However, it is actually possible to mix and match AOT and JIT models of execution in one runtime: re-balancing that AOT vs JIT mix is the goal of the first EA release of project Leyden."
msgstr "GraalVMのネイティブ・イメージのアプローチは、一方の極端にあります：すべてがAOTで実行され、伝統的なJavaランタイム・モデルは、もう一方の極端にあります：可能な限り多くのことがJITで実行されます。しかし、実際には1つのランタイムでAOTとJITの実行モデルをミックスしてマッチさせることは可能です。このAOTとJITのミックスのバランスを取り直すことが、プロジェクトLeydenの最初のEAリリースの目標です。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Interestingly, this time-shifting concept is also applied by Quarkus; we called it \"augmentation\" and essentially consists in booting popular frameworks during the build time of the application, to not incur such performance penalties at runtime."
msgstr "興味深いことに、このタイムシフトのコンセプトはQuarkusにも適用されています。私たちはこれを「オーグメンテーション」と呼んでおり、基本的にはアプリケーションのビルド時に人気のフレームワークをブートすることで、実行時にこのようなパフォーマンス上のペナルティを受けないようにするものです。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"A native image build might also take advantage of Profile Guided Optimisations (PGO), which allows it to leverage some data about what's presumably happening at runtime back into the compilation process, guiding its optimisations.\n"
"It's essentially peeking into the future - another form of time-shifting.\n"
"However, it's only peeking into a simulation of runtime metrics, and ultimately, the compiler still needs to make all optimisation tradeoffs Ahead Of Time; this has pros and cons. The primary disadvantage is that any suboptimal decision is cast in stone; luckily there is a fallback mechanism to recover from outright bad decisions, but this mechanism cannot produce new optimal code. The advantage is more decisive for short-lived applications as the tradeoff of carrying all support for JIT optimisations in the runtime is less justifiable when there is barely an opportunity to take advantage of it."
msgstr "ネイティブ・イメージ・ビルドは、プロファイル・ガイドド・オプティマイゼーション（PGO）を利用することもできます。これは、実行時に何が起きているのかについてのデータをコンパイル・プロセスに戻し、最適化の指針とするものです。これは本質的に未来を覗き見ることであり、タイムシフトのもう一つの形です。しかし、これはあくまでランタイム・メトリクスのシミュレーションを覗いているに過ぎず、最終的には、コンパイラーはすべての最適化のトレードオフを前もって行う必要があります。主な欠点は、最適でない決定が石になってしまうことです。幸いなことに、完全に間違った決定から回復するためのフォールバック・メカニズムがありますが、このメカニズムでは新しい最適なコードを生成することはできません。JIT最適化のすべてのサポートをランタイムに搭載するというトレードオフは、それを利用する機会がほとんどない場合には正当化できなくなるためです。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "On a default Java compilation and run, we have two distinct phases: First we compile the source code into bytecode. And then we use that bytecode to run the application."
msgstr "デフォルトのJavaコンパイルと実行では、2つの異なるフェーズがあります：まず、ソース・コードをバイトコードにコンパイルします。そして、そのバイトコードを使ってアプリケーションを実行します。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Class Data Sharing (CDS) as a step to AOT Caching"
msgstr "AOTキャッシングへのステップとしてのクラスデータ共有（CDS）"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Shifting work so it is done AOT is not a wholly new idea as far as the OpenJDK runtime is concerned. OpenJDK has supported a hybrid AOT/JIT class loading model for years with CDS. The observation that led to https://docs.oracle.com/en/java/javase/21/vm/class-data-sharing.html[Class Data Sharing (CDS)] being proposed was that most applications load the same classes every time they run, both JDK classes during JDK bootstrap and application classes during application startup and warmup."
msgstr "OpenJDKのランタイムに関する限り、AOTで行われるように作業をシフトすることは、まったく新しいアイデアではありません。OpenJDKは何年も前から、CDSによってAOTとJITのハイブリッド・クラス・ロード・モデルをサポートしてきました。 link:https://docs.oracle.com/en/java/javase/21/vm/class-data-sharing.html[クラス・データ共有（CDS）が] 提案されるきっかけとなった観察は、ほとんどのアプリケーションは、JDKブートストラップ中のJDKクラスと、アプリケーションのスタートアップとウォームアップ中のアプリケーション・クラスの両方で、実行するたびに同じクラスをロードするということでした。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Loading requires locating a class bytecode file, possibly calling out to a Java ClassLoader, parsing the bytecode then building a JVM-internal model of the class. This internal model unpacks the information packed into the bytecode into a format that enables fast interpreted or compiled execution. If this loading and unpacking work could be done once and the resulting class model efficiently reused on subsequent runs, then that would save time during startup and warm up."
msgstr "ロードには、クラス・バイトコード・ファイルを見つけ、場合によってはJava ClassLoaderを呼び出し、バイトコードを解析し、クラスのJVM内部モデルを構築する必要があります。この内部モデルは、バイトコードに詰め込まれた情報を、高速なインタプリタ実行やコンパイル実行を可能にする形式にアンパックします。このロードとアンパック作業が一度だけ行われ、その結果得られるクラス・モデルをその後の実行で効率的に再利用できれば、起動とウォームアップの時間を節約できます。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Initially CDS optimized loading for a large set of core JDK classes. It worked by booting the JVM and dumping the class model for all classes loaded during startup into an archive file laid out in memory format. The resulting JDK module, class, field, and method graph can then be quickly remapped into memory next time the JVM runs. Loading a class that is present in the archive involves a simple lookup in the AOT class model. Loading a class not present in the archive requires the normal JIT steps of bytecode lookup, parsing and unpacking i.e. CDS implements a hybrid JIT/AOT execution model."
msgstr "当初、CDSはJDKのコア・クラスの大規模なセットのロードを最適化しました。これは、JVMを起動し、起動中にロードされたすべてのクラスのクラスモデルを、メモリ形式にレイアウトされたアーカイブファイルにダンプすることで機能しました。こうして得られたJDKモジュール、クラス、フィールド、メソッドのグラフは、次回JVMの実行時に素早くメモリに再マップすることができます。アーカイブに存在するクラスをロードするには、AOTクラス・モデルの単純なルックアップが必要です。アーカイブに存在しないクラスをロードするには、バイトコードのルックアップ、解析、アンパックといった通常のJITステップが必要です。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Static CDS archives are built during the JVM installation and includes classes from the core libraries. This archive can be used to move part of the class loading to AOT when running the application."
msgstr "スタティックCDSアーカイブは、JVMのインストール中に構築され、コア・ライブラリのクラスを含みます。このアーカイブは、アプリケーションの実行時にクラス・ロードの一部をAOTに移動するために使用できます。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "A default CDS archive for JDK runtime classes has been shipped with every JVM release since JDK17, halving JDK startup time. Improvements were made to CDS to allow application classes to be included in a CDS archive after executing a short application training run. The resulting mixed AOT/JIT operation can provide significant improvements to application startup and warmup times, depending on how well the training run exercises application code. So, selective JIT/AOT operation is not some new thing."
msgstr "JDKランタイム・クラス用のデフォルトのCDSアーカイブは、JDK17以降のすべてのJVMリリースに同梱され、JDKの起動時間が半分になりました。短いアプリケーション・トレーニングの実行後にアプリケーション・クラスをCDSアーカイブに含めることができるように、CDSに改良が加えられました。その結果、AOT/JITの混在動作により、トレーニングの実行がアプリケーション・コードの演習にどの程度適しているかに応じて、アプリケーションの起動時間とウォームアップ時間が大幅に改善されます。つまり、選択的なJIT/AOTオペレーションは新しいものではありません。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "When doing training runs, we create an archive that contains information on how the application runs. This archive includes not only classes from the core libraries, but also classes from our application."
msgstr "トレーニングの実行時には、アプリケーションの実行に関する情報を含むアーカイブを作成します。このアーカイブにはコアライブラリのクラスだけでなく、私たちのアプリケーションのクラスも含まれています。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"Quarkus makes it really easy to generate CDS archives specific to your application code; this feature has been around since some years already: see the https://quarkus.io/guides/appcds[AppCDS guide in Quarkus].\n"
"As Leyden is coming, we aim to evolve this further and fully automate it for Leyden as well, so to get you even more benefits at no additional hassle."
msgstr "link:https://quarkus.io/guides/appcds[Quarkusでは] 、アプリケーションコードに特化したCDSアーカイブを簡単に生成することができます。QuarkusのAppCDSガイドをご覧ください。Leydenのリリースが近づいているため、私たちはこれをさらに進化させ、Leydenでも完全に自動化することを目指しています。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"The goal of Project Leyden is extending the AOT vs JIT trade-off from class loading (as done by CDS) to other JIT operations in the JVM; there's a number of operations which could be \"moved in time\" to AOT, such as creation of heap objects to represent constants, gathering execution profile information, and many more.\n"
"Most importantly, it's moving AOT the lazy linking that normally happens during interpreted execution and the lazy compilation and recompilation that happens when methods have been executed enough times to justify the cost of compilation."
msgstr "Project Leydenの目標は、AOT対JITのトレードオフを、（CDSによって行われるような）クラス・ローディングからJVMの他のJIT操作にまで拡張することです。定数を表すためのヒープ・オブジェクトの生成、実行プロファイル情報の収集など、AOTに「時間的に移動」できる操作が数多くあります。最も重要なのは、通常インタプリタ実行時に発生する遅延リンクと、コンパイルにかかるコストを正当化できるほどメソッドが実行された場合に発生する遅延コンパイルと再コンパイルをAOTに移すことです。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "AOT vs JIT Linkage"
msgstr "AOTとJITの連携"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Linking of classes is another operation that the JVM does lazily. When class bytecode is processed the class is directly linked to its owning module and its owned methods and fields. JIT linkage connects elements of each independent, linked class sub-graph into a fully connected graph where elements from different (class or module) files cross-reference each other."
msgstr "クラスのリンクは、JVMが遅延的に行うもう1つの操作です。クラス・バイトコードが処理されるとき、クラスはその所有するモジュールとその所有するメソッドとフィールドに直接リンクされます。JITリンケージは、各独立したリンクされたクラス・サブグラフの要素を、異なる（クラスやモジュールの）ファイルからの要素が互いに相互参照する完全連結グラフに連結します。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Loading and linking needs to proceed recursively. As one example, every class (except Object) needs to be linked to its super class. Super linkage cannot complete without ensuring the super class is loaded. Indeed, if the super's bytecode cannot be found or is not valid (say it identifies an interface not a class) then a linkage error may occur. Likewise, a new operation or a field get/put operation occurring in some method's bytecode can only be linked after loading the class (and field) named in the new bytecode."
msgstr "ロードとリンクは再帰的に進める必要があります。一例として、（Objectを除く）すべてのクラスは、そのスーパー・クラスにリンクする必要があります。スーパークラスが確実にロードされなければ、スーパークラスのリンクは完了しません。実際、スーパークラスのバイトコードが見つからないか、有効でない場合（クラスではなくインターフェイスを識別しているなど）、リンクエラーが発生する可能性があります。同様に、あるメソッドのバイトコードで発生した新しい操作やフィールドの get/put 操作は、新しいバイトコードで指定されたクラス（とフィールド）をロードした後にのみリンクできます。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Linking is sometimes, but not always, done lazily. Indeed, it is necessary to do some linkage lazily in order to allow loading also to be lazy, otherwise the whole class graph would end up being linked and loaded as soon as the main routine was entered. Super linkage is always done eagerly at the point where the subclass has just been loaded. That is because it is not possible to use a subclass to create instances or execute methods without knowing how the superclass is defined. By contrast, field and method linkage is done lazily. In these cases linkage happens as a side-effect of execution. When a method executes a field get/put or method invoke bytecode for the first time the target field or method is looked up via its owner class, loading it if necessary. The field type or method signature is checked for consistency and details of where to find the field or how to call the method are cached, allowing the next execution of the bytecode to bypass the linkage step."
msgstr "リンクは、常にではありませんが、遅延的に行われることもあります。そうしないと、メイン・ルーチンに入るとすぐにクラス・グラフ全体がリンクされ、ロードされてしまうからです。スーパー・リンケージは常に、サブクラスがロードされた時点でイーガーリーに行われます。これは、スーパークラスがどのように定義されているかを知らずに、サブクラスを使用してインスタンスを作成したりメソッドを実行したりすることはできないからです。対照的に、フィールドとメソッドのリンケージは遅延的に行われます。これらの場合、リンケージは実行の副作用として起こります。メソッドが初めてフィールドの get/put やメソッドの invoke バイトコードを実行するとき、対象となるフィールドやメソッドがオーナー・クラスを経由して検索され、必要であればロードされます。フィールドの型やメソッドのシグネチャの一貫性がチェックされ、フィールドの場所やメソッドの呼び出し方法の詳細がキャッシュされます。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "As with lazy loading, this lazy approach results in almost the exact same linkage being established on every run. The time spent stopping and restarting execution to lazily connect the class graph comprises a noticeable percentage of JDK startup, application startup and application warm up (time to peak running). We could speed up startup and, more crucially, warm up time if we could pre-compute this linkage and avoid the need to establish it at runtime."
msgstr "遅延ロードと同様に、この遅延アプローチでは、実行のたびにほとんど同じリンケージが確立されます。クラス・グラフを遅延的に接続するために実行を停止したり再開したりする時間は、JDKの起動、アプリケーションの起動、アプリケーションのウォームアップ（実行がピークに達するまでの時間）に占める割合が大きくなります。このリンケージを事前に計算し、実行時に確立する必要性を避けることができれば、起動時間とウォームアップ時間を短縮できます。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Synergy with Quarkus"
msgstr "クアルカスとのシナジー"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Loading and linking of classes is an important step in the warm up of the application because it involves searching through the whole classpath for all classes and objects referenced by the bytecode the JVM is going to run. By default, this is done as a lazy operation because loading and linking all existing classes in the classpath would not only require a bigger memory footprint, but also a bigger warm up time. This is why the JVM only compiles and links the bytecode that is going to be used."
msgstr "クラスのロードとリンクは、アプリケーションのウォームアップにおいて重要なステップです。なぜなら、JVMが実行しようとしているバイトコードによって参照されるすべてのクラスとオブジェクトをクラスパス全体を通して検索する必要があるからです。デフォルトでは、クラスパス内のすべての既存クラスをロードしてリンクすると、メモリ・フットプリントが大きくなるだけでなく、ウォームアップ時間も大きくなるため、これは遅延操作として行われます。このため、JVMは使用される予定のバイトコードだけをコンパイルしてリンクします。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "This is a process that Quarkus already speeds up by, among other strategies, aggressively reducing the set of classes included in the classpath, so the search for matches is faster. The search for classes is also accelerated by indexes which Quarkus can generate when it fully analyzes the application at build time. But it is still a heavy operation that is difficult to execute ahead of time, before we know what is going to be run and how. Quarkus might be able to provide some additional hints to the linker in the future."
msgstr "Quarkusでは、クラスパスに含まれるクラスのセットを積極的に削減することで、一致するクラスの検索を高速化しています。クラスの検索は、Quarkusがビルド時にアプリケーションを完全に分析したときに生成できるインデックスによっても高速化されます。しかし、何がどのように実行されるかを知る前に、前もって実行するのはまだ困難です。Quarkusは、将来的にリンカーに追加のヒントを提供できるかもしれません。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The first improvement Leyden is offering to improve startup time is to upgrade the AOT model originally developed as part of the CDS project to encompass not just pre-loading of classes but also pre-linking, as described in https://openjdk.org/jeps/8315737[JEP Ahead-of-Time Class Linking]."
msgstr "起動時間を改善するために Leyden が提供する最初の改善は、CDS プロジェクトの一部として元々開発された AOT モデルをアップグレードして、 link:https://openjdk.org/jeps/8315737[JEP Ahead-of-Time Class Linking] で説明されているように、クラスのプリロードだけでなくプリリンクも包含するようにすることです。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"An AOT Cache can be generated during a training run that bootstraps the JVM and, optionally, executes application-specific code.\n"
"As with a CDS archive, the AOT Cache stores a class graph for all classes loaded during the training run in a format that allows it to be quickly remapped on a subsequent run. The stored graph also includes any linkage information established by code executed during the training run. Pre-cached links avoid the need to stop and start execution to perform linkage on subsequent runs."
msgstr "AOT Cache は、JVM をブートストラップし、オプションでアプリケーション固有のコードを実行するトレーニング実行中に生成できます。CDS アーカイブと同様に、AOT Cache には、トレーニング実行中にロードされたすべてのクラスのクラス・グラフが、後続の実行時にすばやく再マップできる形式で保存されます。保存されたグラフには、トレーニング実行中に実行されたコードによって確立されたリンク情報も含まれます。事前にキャッシュされたリンクにより、次回以降の実行時にリンケージを実行するために実行を停止したり開始したりする必要がなくなります。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Leyden's AOT Cache contains a lot more pre-generated content that allows us to move part of the load, link, and compiling to AOT, allowing for faster startup and warm up of the application."
msgstr "LeydenのAOTキャッシュには、より多くの事前生成されたコンテンツが含まれており、ロード、リンク、コンパイルの一部をAOTに移行することで、アプリケーションの起動とウォームアップを高速化することができます。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"Remember that the training run enables some of the loading and linking to be done AOT but that anything not trained for will still be performed via the regular JIT process: the AOT approach is not required to be applied comprehensively, so that the JVM can fallback to the regular loading system for the use cases which can not benefit from AOT processing.\n"
"This ability to fallback to \"regular JIT processing\" is a luxury that GraalVM native images can't use."
msgstr "トレーニングの実行によって、ロードとリンクの一部がAOTで実行されるようになりますが、トレーニングされていないものは、通常のJITプロセスを介して実行されることを覚えておいてください：AOTアプローチは、JVMがAOT処理の恩恵を受けることができないユースケースのために通常のロードシステムにフォールバックできるように、包括的に適用する必要はありません。この「通常のJIT処理」にフォールバックする能力は、GraalVMネイティブ・イメージでは使用できない贅沢なものです。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "JIT vs AOT Compilation"
msgstr "JITコンパイルとAOTコンパイル"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"Another well-known lazy operation the JVM performs is JIT (runtime) compilation. Method bytecode is normally interpreted, but the JVM will lazily translate bytecode to equivalent machine code.\n"
"Since generating optimal machine code is an expensive operation, it performs this compilation task selectively, only bothering to compile methods that have been invoked quite a few times."
msgstr "JVMが実行するもう一つのよく知られた遅延操作は、JIT（ランタイム）コンパイルです。メソッドのバイトコードは通常解釈されますが、JVMはバイトコードを同等のマシンコードに遅延翻訳します。最適なマシン・コードを生成するのは高価な操作なので、JVMはこのコンパイル・タスクを選択的に実行し、かなりの回数呼び出されたメソッドだけをわざわざコンパイルします。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "JIT compilation is also 'adaptive' i.e. the JVM will lazily recompile some methods, using different 'tiers' or levels of compilation."
msgstr "JITコンパイルは「適応的」でもあります。つまり、JVMはいくつかのメソッドを、さまざまな「階層」またはコンパイル・レベルを使用して、遅延的に再コンパイルします。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "A tier 1 compile generates code that is only lightly optimised, based on very limited execution profile data."
msgstr "ティア1コンパイルは、非常に限定された実行プロファイルデータに基づいて、軽く最適化されただけのコードを生成します。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "A tier 2 compile also generates lightly optimized code but instruments it to profile control flow."
msgstr "ティア2コンパイルもまた、軽度に最適化されたコードを生成しますが、制御フローをプロファイルするためのインストゥルメントを生成します。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Tier 3 compilation adds further instrumentation that records many more details about what gets executed, including with what type of values."
msgstr "第3層のコンパイルでは、さらにインスツルメンテーションが追加され、どのような値で何が実行されるかなど、より多くの詳細が記録されます。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "A tier 4 compile uses all gathered profile information and performs a great deal of optimization."
msgstr "ティア4コンパイルは、収集したすべてのプロファイル情報を使用し、多くの最適化を実行します。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Tier 1 - 3 compilations omit many possible optimizations in order to deliver compiled code quickly. A tier 4 compilation can take much longer to complete so it is only attempted for a small subset of very frequently executed methods."
msgstr "ティア1～3のコンパイルでは、コンパイルされたコードを素早く提供するために、多くの最適化が省略されます。第 4 層コンパイルは完了するまでにかなり時間がかかるため、非常に頻繁に実行されるメソッドの小さなサブセットに対してのみ試みられます。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"Sometimes, the code is compiled with substantial optimisations based on 'speculative' assumptions extrapolated from the profiling data.\n"
"In such cases, the compiler will make an optimistic assumption about a condition to be consistently true in the future yet include an efficient check to verify the assumption during execution so that the semantics of the program are not affected in case this educated guess eventually turns out to be false; when this is detected, the code is de-optimised, returning at a previous tier of compilation and the profiling data is adjusted, so that it will eventually be recompiled with better information.\n"
"Essentially, some parts of code might get recompiled multiple times and occasionally revert to a lower tier: it's an highly dynamic process."
msgstr "プロファイリング・データから推定された「推測的な」仮定に基づいて、コードが大幅に最適化されてコンパイルされることもあります。このような場合、コンパイラは、ある条件が将来一貫して真であるという楽観的な推測を行いますが、この推測が最終的に誤りであることが判明した場合にプログラムのセマンティクスに影響を与えないように、実行中にその推測を検証するための効率的なチェックを行います。これが検出されると、コードは最適化解除され、コンパイルの前の階層に戻り、プロファイリング・データが調整されます。基本的に、コードの一部は何度も再コンパイルされ、時には低階層に戻るかもしれません。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Peak optimization is reached when most of the running code is compiled at the highest tier, and background compilation activities become very rare or, ideally, none at all."
msgstr "最適化のピークに達するのは、実行中のコードのほとんどが最上位層でコンパイルされ、バックグラウンドでのコンパイル作業がごくまれになるか、理想的にはまったく行われなくなるときです。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Compiling code for peak performance also requires quite some resources, so performing this work ahead of time can also save precious CPU cycles during the application bootstrap, and can manifest in substantial memory savings as well: Java developers aren't used to measure the memory costs of the JIT compiler, but the fact that it's hidden doesn't imply it's non-existent; and while this might be a detail for large enterprise servers, it's quite important to be aware of such resource costs when developing microservices or simply aiming for smaller, more power efficient targets."
msgstr "そのため、この作業を前もって行うことで、アプリケーションのブートストラップ中の貴重なCPUサイクルを節約することができます：Java開発者は、JITコンパイラのメモリコストを測定することに慣れていませんが、それが隠されているという事実は、それが存在しないということを意味するものではありません。これは、大規模なエンタープライズ・サーバにとっては細かいことかもしれませんが、マイクロサービスを開発するときや、より小さく、より電力効率の高いターゲットを目指すときには、このようなリソースコストを意識することは非常に重要です。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "But there are some limitations on what we can optimise before runtime just by examining the bytecode. For example, extensive use of reflection prevents the compiler from predicting which symbols will be loaded, linked, and most used at runtime."
msgstr "しかし、バイトコードを調べるだけで、実行前に最適化できることには限界があります。例えば、リフレクションを多用すると、どのシンボルがロードされ、リンクされ、実行時に最も使用されるかをコンパイラが予測できなくなります。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The Leyden project has already sucessfully prototyped shifting the work of method compilation from JIT to AOT. Execution and compilation of methods is tracked during the training run. At the end of the run any associated profiling information and compiled code for the method are saved to the AOT Cache, allowing them to be quickly mapped back into memory and reused when the application is next run."
msgstr "Leydenプロジェクトでは、メソッドのコンパイル作業をJITからAOTに移行するプロトタイプをすでに成功させています。メソッドの実行とコンパイルはトレーニング実行中に追跡されます。実行が終了すると、メソッドに関連するプロファイリング情報とコンパイルされたコードがAOTキャッシュに保存され、アプリケーションを次回実行する際に、それらを素早くメモリにマッピングして再利用することができます。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "As with AOT loading and linking, the training run enables some of the work of profiling and compiling to be done AOT but allows anything not trained still to be compiled via the regular JIT compilation process. Note that method code does not need to have been compiled at the highest tier in order to be saved. Also, when code compiled at a lower tier is restored it can still be recompiled at a higher level."
msgstr "AOTのロードとリンクと同様に、トレーニングの実行により、プロファイリングとコンパイルの作業の一部をAOTで行うことができますが、トレーニングされていないものは通常のJITコンパイルプロセスでコンパイルすることができます。メソッド・コードを保存するためには、最上位階層でコンパイルされている必要はないことに注意してください。また、下位階層でコンパイルされたコードが復元された場合でも、上位階層で再コンパイルすることができます。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Compiled code can also be deoptimized and re-optimized to adapt to different runtime conditions, just as with code compiled in the current runtime. So, the use of AOT compilation is fully integrated into OpenJDK's adaptive, dynamic compilation and recompilation model: even if some assumptions made during AOT compilation turn out to be suboptimal, the just-in-time compiler can intervene at runtime and improve the code with the new information."
msgstr "コンパイルされたコードは、現在のランタイムでコンパイルされたコードと同様に、異なるランタイム条件に適応するように最適化を解除したり、再最適化したりすることもできます。そのため、AOTコンパイルの使用は、OpenJDKの適応的で動的なコンパイルと再コンパイルのモデルに完全に統合されています。AOTコンパイル時に行われたいくつかの仮定が最適でないことが判明した場合でも、ジャストインタイム・コンパイラが実行時に介入し、新しい情報を使ってコードを改善することができます。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "How to play with it"
msgstr "遊び方"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The first step would be to install one of the early Leyden builds that you can find at https://jdk.java.net/leyden/[jdk.java.net/leyden/]."
msgstr "最初のステップは、 link:https://jdk.java.net/leyden/[jdk.java.net/leyden/に] ある初期のLeydenビルドのいずれかをインストールすることです。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Make sure that you have installed it correctly by running the following command:"
msgstr "以下のコマンドを実行して、正しくインストールされていることを確認してください："

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Go to the application you want to test Leyden with and start a first training run:"
msgstr "ライデンをテストしたいアプリケーションにアクセスし、最初のトレーニングを開始します："

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "This will generate the archive files with all the profiling information needed to speed up the production run."
msgstr "これにより、本番稼働のスピードアップに必要なすべてのプロファイリング情報を含むアーカイブファイルが生成されます。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Now that we have them, we can run our application using the Leyden enhancements:"
msgstr "これで、ライデンの機能拡張を使ってアプリケーションを実行できるようになりました："

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Potentially needed workarounds"
msgstr "潜在的に必要な回避策"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Since it’s early days for the Leyden project, there are some known issues. The following instructions shouldn’t be necessary for the final versions but you might need them today."
msgstr "Leydenプロジェクトはまだ始まったばかりなので、いくつかの既知の問題があります。以下の説明は最終バージョンでは必要ありませんが、今日必要かもしれません。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Force the use of G1GC"
msgstr "G1GCの使用を強制"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "To benefit from the natively compiled code in AOT archives, the garbage collector used at runtime needs to match the same garbage collector used when you recorded the AOT archives."
msgstr "AOTアーカイブでネイティブにコンパイルされたコードの恩恵を受けるには、実行時に使用されるガベージコレクタが、AOTアーカイブを記録したときに使用されたガベージコレクタと同じである必要があります。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Remember that the JVM’s default choice of garbage collector is based on ergonomics; normally this is nice but it can cause some confusion in this case; for example if you build on a large server it will pick G1GC by default, but then when you run the application on a server with constrained memory it would, by default, pick SerialGC."
msgstr "JVMのデフォルトのガベージ・コレクタの選択は、人間工学に基づいていることを覚えておいてください。通常、これは良いことですが、このケースではいくつかの混乱を引き起こす可能性があります。例えば、大規模なサーバーでビルドした場合、デフォルトでG1GCを選択しますが、メモリに制約のあるサーバーでアプリケーションを実行すると、デフォルトでSerialGCを選択します。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "To avoid this mismatch it’s best to pick a garbage collector explicitly; and since several AOT related optimisations today only apply to G1, let’s enforce the use of G1GC."
msgstr "このミスマッチを避けるには、ガベージコレクタを明示的に選択するのがベストです。今日、いくつかのAOT関連の最適化はG1にしか適用されないので、G1GCの使用を強制しましょう。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Force using G1GC:"
msgstr "G1GCを使用したフォース："

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "N.B. you need to use this consistently on both the process generating the AOT archives and the runtime."
msgstr "注：AOTアーカイブを生成するプロセスとランタイムの両方で一貫して使用する必要があります。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Force the G1 Region sizes"
msgstr "G1領域のサイズを強制"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"As identified and reported by the Quarkus team to our colleagues working on Project Leyden, beyond enforcing a specific garbage collector, one should also ensure that the code stored in AOT archives is being generated with the same G1 region sizes as what’s going to be used at runtime, or one risks segmentation faults caused by it wrongly identifying regions.\n"
"See https://bugs.openjdk.org/browse/JDK-8335440 for details, or simply set:"
msgstr "QuarkusチームがProject Leydenの同僚に報告したように、特定のガベージコレクタを強制するだけでなく、AOTアーカイブに格納されているコードが、実行時に使用されるものと同じG1リージョンサイズで生成されていることを確認する必要があります。詳細は link:https://bugs.openjdk.org/browse/JDK-8335440[https://bugs.openjdk.org/browse/JDK-8335440 を参照してください] ："

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Configure G1HeapRegionSize explicitly:"
msgstr "G1HeapRegionSize を明示的に設定します："

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Failure to terminate in containers"
msgstr "コンテナでの解約の不履行"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "This issue has already been resolved, but in case you’re using an older version of project Leyden and it fails to exit on regular container termination, you might be affected by https://bugs.openjdk.org/browse/JDK-8333794[JDK-8333794]."
msgstr "この問題はすでに解決されていますが、古いバージョンのproject Leydenを使用していて、通常のコンテナ終了時に終了に失敗する場合、 link:https://bugs.openjdk.org/browse/JDK-8333794[JDK-8333794の] 影響を受ける可能性があります。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Workaround for JDK-8333794:"
msgstr "JDK-8333794 の回避策："

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Current status of Project Leyden"
msgstr "ライデン・プロジェクトの現状"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "There are already experimental https://jdk.java.net/leyden/[early-access builds of Leyden] that can be tested based on https://openjdk.org/jeps/8315737[this draft JEP about Ahead-of-Time Class Linking]."
msgstr "link:https://openjdk.org/jeps/8315737[このJEP草案（Ahead-of-Time Class Linking] ）に基づいてテストできる link:https://jdk.java.net/leyden/[ライデンの] 実験的な link:https://jdk.java.net/leyden/[早期アクセスビルドが] すでにあります。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "With the Leyden Project, the idea of leveraging a \"training run\" has been extended to a wider range of data structures embedded in the new AOT cache. Now the cache produced by the AOT process contains the following data:"
msgstr "ライデンプロジェクトでは、「トレーニングラン」を活用するというアイデアが、新しいAOTキャッシュに組み込まれたより広範なデータ構造に拡張されました。現在、AOTプロセスによって生成されるキャッシュには、以下のデータが含まれています："

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Class file events with historical data (Classes loaded and linked, Compilations)"
msgstr "履歴データを含むクラス・ファイル・イベント (ロードおよびリンクされたクラス、コンパイル)"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Resolution of API points and indy (stored in constant pool images in the AOT archive). If you have lambdas in your code, they are captured here."
msgstr "APIポイントとインディの解決（AOTアーカイブの定数プールイメージに格納）。コードにラムダがある場合は、ここでキャプチャされます。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Pre-created constant objects in the Java heap (String and Class<?> constants)"
msgstr "Javaヒープにあらかじめ作成された定数オブジェクト（StringおよびClass<?）"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Execution profiles and some compiled native code (all tiers)"
msgstr "実行プロファイルと一部のコンパイル済みネイティブコード（全階層）"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Leyden is also a hot topic at the https://openjdk.org/projects/mlvm/jvmlangsummit/agenda.html[JVM Language Summit] this year; as soon as the recordings of the talks about Leyden are publicly available we'll add the links here."
msgstr "Leydenは今年の link:https://openjdk.org/projects/mlvm/jvmlangsummit/agenda.html[JVM言語サミットでも] 話題になっています。Leydenに関する講演の録音が公開され次第、ここにリンクを追加します。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Some known limitations"
msgstr "いくつかの既知の制限"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "This is an experimental project being developed by multiple teams having different approaches and focuses. Limitations explained here are being worked on at the time of writing this blog post."
msgstr "このプロジェクトは、異なるアプローチと焦点を持つ複数のチームによって開発されている実験的プロジェクトです。ここで説明されている制限は、このブログ記事を書いている時点で作業中です。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "One of the main issues is that functionality is currently only available for x86_64 and AArch64 architectures at the moment."
msgstr "主な問題のひとつは、現在のところ機能がx86_64およびAArch64アーキテクチャでしか利用できないことです。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Also, current developments rely on a flat classpath. If the application is using custom classloaders, then it may not benefit as much as it could as it may miss caching many classes."
msgstr "また、現在の開発はフラットなクラスパスに依存しています。アプリケーションがカスタムのクラスローダを使用している場合、多くのクラスをキャッシュし損ねる可能性があるため、あまり恩恵を受けられないかもしれません。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The same happens if the application is intensively using reflection. Quarkus avoids reflection whenever possible, preferring to resolve reflective calls at build time as well - so there’s a nice synergy at play."
msgstr "アプリケーションがリフレクションを多用している場合も同様です。Quarkusは可能な限りリフレクションを避け、ビルド時にリフレクション呼び出しを解決することを好みます。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"However Quarkus in “fast-jar” mode, which is the default packaging mode, will use a custom classloader which currently would get in the way of some Leyden optimisations. One could use a different packaging mode in Quarkus to get more prominent benefits from Leyden, but doing so would disable other Quarkus optimisations, so the comparison wouldn’t be entirely fair today.\n"
"We hope to work on improvements in this area to have all possible benefits, combined."
msgstr "しかし、Quarkusのデフォルトパッケージングモードである \"fast-jar \"モードでは、カスタムクラスローダを使用します。Quarkusで別のパッケージングモードを使用することで、Leydenの恩恵をより顕著に受けることができますが、そうすると、他のQuarkusの最適化が無効になるため、現在の比較は完全に公平ではありません。私たちは、可能なすべての利点を組み合わせることができるよう、この分野の改善に取り組みたいと考えています。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The focus on these first early releases has been on bootstrap times. There are measurable, significant startup time improvements, due to AOT loading and linking. In some cases, these improvements on startup time have worsened the memory footprint of some applications. That’s an already known issue that is being worked on, and the expected outcome is to improve memory footprint as well, so we would suggest not worrying too much about total memory consumption at this stage."
msgstr "最初の初期リリースでは、起動時間に重点を置きました。AOT のロードとリンクにより、起動時間は測定可能なほど大幅に改善されました。場合によっては、起動時間の改善により、アプリケーションのメモリ・フットプリントが悪化するものもあります。これはすでに知られている問題で、現在取り組んでおり、期待される結果はメモリ・フットプリントも改善することです。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Since the AOT archives include machine specific optimisations such as the native code generated by the C2 compiler, the training run and the production run must be done on the same type of hardware and JDK versions; it also requires using the same JAR-based classpaths and the same command line options."
msgstr "AOTアーカイブには、C2コンパイラによって生成されたネイティブコードなど、マシン固有の最適化が含まれているため、トレーニング実行と本番実行は、同じ種類のハードウェアとJDKバージョンで実行する必要があります。また、同じJARベースのクラスパスと同じコマンドラインオプションを使用する必要があります。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Although the training run can use a different Main class to the one used for running the application, for example a test class that simulates usage."
msgstr "トレーニングの実行では、アプリケーションの実行に使用されるものとは異なる Main クラスを使用することができます。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "What is on the roadmap for Leyden?"
msgstr "ライデンのロードマップは？"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "There’s still work to be done regarding classes that can’t be loaded and linked in AOT with the current implementation. For example, classes loaded using a user-defined class loader. There’s also room to improve the way the training runs are made, maybe allowing the user to tweak the results to influence decisions."
msgstr "現在の実装ではAOTでロードおよびリンクできないクラスについては、まだやるべきことがあります。例えば、ユーザー定義のクラス・ローダーを使ってロードされるクラスなどです。また、トレーニングの実行方法を改善する余地もあり、ユーザーが結果を微調整して意思決定に影響を与えることができるようになるかもしれません。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Currently, the https://bugs.openjdk.org/browse/JDK-8326035[Z Garbage Collector] does not support AOT object archiving. There is an active effort to make sure all Garbage Collectors are compatible with these enhancements."
msgstr "現在、 link:https://bugs.openjdk.org/browse/JDK-8326035[Z ガーベッジ・コレクタは] AOT オブジェクト・アーカイブをサポートしていません。すべてのガベージ・コレクタがこれらの機能拡張に対応できるよう、積極的に取り組んでいます。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "There are also other things planned in the roadmap for Leyden, like adding condensers. https://openjdk.org/projects/leyden/notes/03-toward-condensers[Condensers] will be composable transformers of the source code in AOT that modify the source code optimising it. Each developer will be able to define a pipeline of condensers that improves their source code before compiling it into bytecode; this is very interesting to the Quarkus team but condensers aren’t available yet."
msgstr "Leydenのロードマップには、他にもコンデンサーの追加などが計画されています。 link:https://openjdk.org/projects/leyden/notes/03-toward-condensers[コンデンサは] 、AOTのソースコードを最適化するためにソースコードを修正する、コンポーザブルな変換器になります。各開発者は、バイトコードにコンパイルする前にソースコードを改良するコンデンサーのパイプラインを定義できるようになります。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The OpenJDK team is actively extending the range of compiled code that can be saved to and restored from the AOT cache. Our colleagues from Red Hat’s OpenJDK team are directly involved in this effort, looking into save and restore of auxiliary code that is normally generated at runtime and used to provide optimized code for 'intrinsic' methods or to link compiled Java method code to the compiled C code that implements the JVM, the interpreter and other compiled C libraries."
msgstr "OpenJDK チームは、AOT キャッシュに保存および復元できるコンパイル済みコードの範囲を積極的に拡張しています。Red HatのOpenJDKチームの同僚がこの取り組みに直接関与しており、通常は実行時に生成され、「組込み」メソッドに最適化されたコードを提供したり、コンパイルされたJavaメソッドコードをJVMやインタプリタ、その他のコンパイルされたCライブラリを実装するコンパイルされたCコードにリンクするために使用される補助コードの保存と復元について調べています。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Will Leyden replace GraalVM's native-image capabilities?"
msgstr "LeydenはGraalVMのネイティブ・イメージ機能に取って代わるのでしょうか？"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The short answer is no."
msgstr "短い答えはノーです。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"If you want the absolute smallest footprint and ensure that absolutely no \"dynamic\" adaptations happen at runtime, GraalVM native images are the way to go. Just think about it: to support the dynamic aspects that the JVM normally provides,\n"
"even in very minimal form, you would need some code which is able to perform this work, and some memory and some computational resources to run such code and adapt your runtime safely; this is a complex feature and will never be completely free, even in the case Leyden evolved significantly beyond the current plans."
msgstr "絶対的に最小のフットプリントで、実行時に全く「動的な」適応が起こらないようにしたいのであれば、GraalVMネイティブ・イメージが最適です。考えてみてください：JVMが通常提供する動的な側面をサポートするためには、非常に最小限の形であっても、この作業を実行できるいくつかのコードと、そのようなコードを実行し、ランタイムを安全に適応させるためのいくつかのメモリと計算リソースが必要です。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The architecture of Quarkus enables developers to define an application in strict \"closed world\" style, and this approach works extremely well in combination with GraalVM native images, but the Quarkus design works indeed very well on the bigger, dynamic JVMs as well."
msgstr "Quarkusのアーキテクチャにより、開発者は厳格な「閉じた世界」スタイルでアプリケーションを定義することができ、このアプローチはGraalVMネイティブ・イメージとの組み合わせで非常にうまく機能します。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The ability that Quarkus offers to create a closed world application doesn't imply that you should necessarily be doing so; in fact there are many applications which could benefit from a bit more dynamism, some more runtime configurability or auto-adaptability, and Quarkus also allows to create such applications while still benefiting from very substantial efficiency improvements over competing architectures, and even over competing runtimes and languages."
msgstr "Quarkusが提供するクローズドワールドのアプリケーションを作成する機能は、必ずしもそうすべきことを意味するわけではありません。実際、もう少しダイナミズムやランタイムの設定可能性、自動適応性から恩恵を受けることができるアプリケーションは多くあり、Quarkusは、競合アーキテクチャや競合ランタイム、競合言語よりも非常に大幅な効率改善の恩恵を受けながら、そのようなアプリケーションを作成することもできます。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "We're very excited by Project Leyden as it allows to substantially improve bootstrap times, warmup times, and overall costs even for the \"regular\" JVM, so retaining all the benefits of a dynamic runtime and an adaptative JIT compiler, and this will be a fantastic option for all those applications for which a fully AOT native image might not be suitable: you'll get some of the benefits from native-image (not all of them) but essentially for free, at no drawbacks."
msgstr "プロジェクト・ライデンによって、「通常の」JVMであってもブートストラップ時間、ウォームアップ時間、そして全体的なコストを大幅に改善することができるので、私たちは非常に興奮しています。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "We also hope it will bring better defined semantics in regards to running certain phases “ahead of time” (or later); there is a very interesting read on this topic by Mark Reinhold: https://openjdk.org/projects/leyden/notes/02-shift-and-constrain[Selectively Shifting and Constraining Computation] ; from a perspective of Quarkus developers, we can confirm that improvements in the language specification in this area would be very welcome, and also improve the quality and maintainability of applications compiled with GraalVM native-image(s)."
msgstr "このトピックについては、Mark Reinholdが非常に興味深い記事を書いています：Quarkus開発者の観点から、この分野の言語仕様の改善は大歓迎であり、GraalVMネイティブイメージでコンパイルされたアプリケーションの品質と保守性を向上させるものであることを確認できます。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "For these reasons, Quarkus will definitely not deprecate support for native images; it's more plausible that, eventually, the \"full JVM\" will always be benefiting from Leyden powered improvements, and as usual we'll work to make these benefits work in synergy with our architecture, and at minimal effort for you all."
msgstr "これらの理由から、Quarkusは間違いなくネイティブイメージのサポートを非推奨にするでしょう。最終的には、\"フルJVM \"は常にLeydenによる改良の恩恵を受けることになるでしょう。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "Essentially both the JVM and the native-image options are bound to benefit from this initiative. It's a great time to be a Java developer!"
msgstr "本質的に、JVMとネイティブ・イメージ・オプションの両方が、このイニシアチブから恩恵を受けるに違いありません。Java開発者にとっては素晴らしい時代です！"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "How can I make sure this will work for me?"
msgstr "どうすれば、これが私のために働くことを確認できますか？"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "The best way to make sure your application benefits from Leyden is to start experimenting early and participate in the development. It would be great to add real-world feedback from a perspective of Quarkus users."
msgstr "あなたのアプリケーションがLeydenの恩恵を確実に受けるための最善の方法は、早い段階から実験を開始し、開発に参加することです。Quarkusユーザーの視点からの実世界のフィードバックを追加することは素晴らしいことです。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid "If you spend some time testing your application with the https://jdk.java.net/leyden/[early-access builds of Leyden], and https://bugs.openjdk.org/browse/JDK-8332177?jql=issuetype%20%3D%20Bug%20AND%20status%20%3D%20Open%20AND%20labels%20%3D%20leyden[reporting any bugs] or weird behaviour the developers will take your specificities into account."
msgstr "link:https://jdk.java.net/leyden/[Leydenのアーリーアクセスビルドで] アプリケーションをテストし、 link:https://bugs.openjdk.org/browse/JDK-8332177?jql=issuetype%20%3D%20Bug%20AND%20status%20%3D%20Open%20AND%20labels%20%3D%20leyden[バグや] 奇妙な動作を link:https://bugs.openjdk.org/browse/JDK-8332177?jql=issuetype%20%3D%20Bug%20AND%20status%20%3D%20Open%20AND%20labels%20%3D%20leyden[報告して] いただければ、開発者はあなたの特殊性を考慮します。"

#: _posts/2024-08-06-quarkus-and-leyden.adoc
#, fuzzy
msgid ""
"The OpenJDK issue tracker isn’t open to everyone, but you’re also very welcome to provide feedback on our https://quarkus.io/discussion/[Quarkus channels]; we can then relay any suggestions to our colleagues who are directly working on project Leyden.\n"
"You can also use the https://mail.openjdk.org/mailman/listinfo/leyden-dev[Leyden mailing list]."
msgstr "OpenJDK issue tracker は誰にでも公開されているわけではありませんが、私たちの link:https://quarkus.io/discussion/[Quarkus チャンネルに] フィードバックを提供していただくことも大歓迎です。 link:https://mail.openjdk.org/mailman/listinfo/leyden-dev[Leyden メーリングリストを] 利用することもできます。"

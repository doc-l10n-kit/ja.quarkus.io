msgid ""
msgstr ""
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: doc-l10n-kit"

#. type: YAML Front Matter
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:2
msgid "post"
msgstr "post"

#. type: YAML Front Matter
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:3
#, fuzzy
msgid "How to select the \"right\" service with Stork?"
msgstr "Storkで \"正しい \"サービスを選択する方法とは？"

#. type: YAML Front Matter
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:4
#, fuzzy
msgid "2022-07-15"
msgstr "2022-07-15"

#. type: YAML Front Matter
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:5
#, fuzzy
msgid "stork"
msgstr "stork"

#. type: YAML Front Matter
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:6
#, fuzzy
msgid "How Stork selects the best service instance and the various built-in stategies."
msgstr "Storkが最適なサービスインスタンスを選択する方法と、様々な組み込みstategy。"

#. type: YAML Front Matter
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:7
msgid "cescoffier"
msgstr "cescoffier"

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:10
#, fuzzy
msgid ""
"The essence of distributed systems resides in the interaction between _services_.\n"
"In modern architectures, you often have multiple instances of your service to share the load or improve the resilience by redundancy."
msgstr "分散システムの本質は、 _サービス_ 間の相互作用に存在する。現代のアーキテクチャでは、負荷を分担したり、冗長性によって耐性を向上させるために、サービスのインスタンスを複数用意することが多い。"

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:13
#, fuzzy
msgid ""
"But, when you have all these instances, how do you select the _best_ one? That's where Stork helps.\n"
"Stork is a service discovery and load balancing framework. Stork will locate and choose the most appropriate instance for each call.\n"
"In this post, we will look into some of the load-balancing strategies offered by Stork, so you can decide which one is the best for you."
msgstr "でも、これだけの事例がある中で、どうやって _最適な_ ものを選べばいいのでしょうか？そこで、Storkが役に立ちます。Storkはサービス発見とロードバランシングのフレームワークです。Storkは、それぞれの呼び出しに対して最も適切なインスタンスを探し出し、選択します。この記事では、Storkが提供するロードバランシング戦略のいくつかを見て、どれが最適か判断できるようにします。"

#. type: Title ==
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:17
#, fuzzy
msgid "Playground"
msgstr "遊び場"

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:19
#, fuzzy
msgid ""
"When your application needs to invoke a remote service (2), it asks Stork to locate this service (3).\n"
"This service discovery step retrieves the service instances. You may have a single instance, which eases the selection process, but you can also have multiple instances available.\n"
"Then, you need to pick one.\n"
"That's where Stork load balancing capability comes and selects the instance (4)."
msgstr "アプリケーションがリモートサービスを呼び出す必要がある場合(2)、Storkにこのサービスの場所を特定するよう依頼します(3)。このサービス発見ステップでは、サービスインスタンスを取得します。インスタンスは1つで、選択プロセスが容易になりますが、複数のインスタンスが利用可能な場合もあります。そして、1つを選ぶ必要があります。そこで、Storkのロードバランシング機能が登場し、インスタンスを選択します（4）。"

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:24
#, fuzzy
msgid ""
"To illustrate this service selection feature, we need an application.\n"
"The following picture represents our system:"
msgstr "このサービス選択機能を説明するために、アプリケーションを用意する必要があります。次の図は、私たちのシステムを表しています："

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:29
#, fuzzy
msgid "You can find the source code on https://github.com/cescoffier/stork-load-balancing-playground[https://github.com/cescoffier/stork-load-balancing-playground]."
msgstr "ソースコードは https://github.com/cescoffier/stork-load-balancing-playground に掲載されています。"

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:31
#, fuzzy
msgid "The system is composed of three service instances: blue, yellow, and green:"
msgstr "システムは、青、黄、緑の3つのサービスインスタンスで構成されています："

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:33
#, fuzzy
msgid "The blue instance returns 🔵 ."
msgstr "青インスタンスは🔵を返します。"

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:34
#, fuzzy
msgid "The yellow instance returns 🟡 . This service is slightly slower than the blue service."
msgstr "黄色のインスタンスは🟡を返します。このサービスは青のサービスより若干遅いです。"

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:35
#, fuzzy
msgid "The green instance returns 🟢 . It's the fastest but with a 20% chance of failing."
msgstr "緑色のインスタンスは🟢を返します。最速ですが、失敗する確率は20%です。"

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:37
#, fuzzy
msgid "The main application contains a REST Client configured to use stork:"
msgstr "メインアプリケーションには、storkを使用するように設定されたREST Clientが含まれています："

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:51
#, fuzzy
msgid "The main endpoint delegates the invocation to the client:"
msgstr "メインエンドポイントは、クライアントに呼び出しを委ねる："

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:71
#, fuzzy
msgid ""
"The UI (exposed on http://localhost:8080[http://localhost:8080]) allows you to invoke the `/dispatcher` endpoint ten times. It will use the REST Client ten times, which will lead to ten service selections.\n"
"These calls can be either:"
msgstr "UI link:http://localhost:8080[（http://localhost:8080に] 公開）では、 `/dispatcher` のエンドポイントを10回呼び出すことができます。これはREST Clientを10回使用し、10回のサービス選択を導くことになります。これらの呼び出しは、次のいずれかになります："

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:74
#, fuzzy
msgid "Sequential calls: it calls the service ten times sequentially, waiting for the previous call to complete before emitting the next one. This approach preserves the ordering."
msgstr "順次呼び出し：サービスを10回順次呼び出し、前の呼び出しが完了するのを待ってから次の呼び出しを行う。この方法では、順序が保たれます。"

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:75
#, fuzzy
msgid "Concurrent calls: it emits ten requests concurrently. You do not control how these requests are sent and the order they are received and processed."
msgstr "同時呼び出し：同時に10個のリクエストを発します。これらのリクエストがどのように送信され、どのような順序で受信・処理されるかは制御できません。"

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:79
#, fuzzy
msgid "Let's now look at the various load-balancing strategies offered by Stork."
msgstr "ここで、Storkが提供する様々なロードバランシング戦略について見てみましょう。"

#. type: Title ==
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:81
#, fuzzy
msgid "The round-robin strategy"
msgstr "ラウンドロビン戦略"

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:83
#, fuzzy
msgid ""
"Stork uses a round-robin if you do not set any load balancing strategy.\n"
"When you call the service (either sequentially or concurrently), you get something like:"
msgstr "Storkは、ロードバランシング戦略を設定しない場合、ラウンドロビンを使用します。サービスを（順次または同時進行で）呼び出すと、次のようなものが表示されます："

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:88
#, fuzzy
msgid ""
"Stork iterates over the available instances. So we can see 🔵 🟡 🟢 🔵 🟡 🟢 🔵 🟡 🟢 sequences.\n"
"It does not change the strategy when the call fails.\n"
"When the green instance fails (❌), it does not evict the instance, continues the iteration, and picks the blue instance, then the yellow instance, and then the green one again."
msgstr "Storkは利用可能なインスタンスに対して反復処理を行います。そのため、🔵🟡🟢🔵🟡🟢の配列を見ることができます。呼び出しが失敗しても戦略を変えない。緑のインスタンスが失敗したとき(❌)、インスタンスを退去させず、反復を続け、青のインスタンスを選び、次に黄色のインスタンスを選び、そしてまた緑のインスタンスを選びます。"

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:92
#, fuzzy
msgid ""
"The round-robin strategy is convenient to dispatch the load equally among a set of service instances.\n"
"When there is a failure, and when a retry is possible, you can use `@Retry` to use the next service instance."
msgstr "ラウンドロビン戦略は、サービスインスタンスの集合に負荷を均等に分散させるのに便利です。障害が発生し、再試行が可能な場合は、 `@Retry` 、次のサービスインスタンスを使用することができます。"

#. type: Title ==
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:95
#, fuzzy
msgid "The random strategy"
msgstr "ランダムストラテジー"

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:97
#, fuzzy
msgid ""
"Unlike the round-robin, iterating over a set of service instances, the random strategy randomly picks an instance.\n"
"The following dependency provides the random strategy:"
msgstr "サービスインスタンスのセットに対して反復するラウンドロビンとは異なり、ランダム戦略はランダムにインスタンスを選択します。次の依存関係は、ランダム戦略を提供します："

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:108
#, fuzzy
msgid "To use this load balancing strategy, you must configure the load balancer of your service:"
msgstr "このロードバランシング戦略を使用するには、サービスのロードバランサーを設定する必要があります："

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:115
#, fuzzy
msgid "As you can see in the picture below, it does not follow a pattern. So, the same service instance can be called multiple times consecutively."
msgstr "下の写真でわかるように、パターン化されていない。そのため、同じサービスインスタンスを連続して複数回呼び出すことができます。"

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:119
#, fuzzy
msgid ""
"This strategy does not share the load equally between the instances.\n"
"It can, in the worst case, pick a busy instance.\n"
"However, suppose the invoked service is also used by other applications (also using the random load balancing).\n"
"In that case, it can be convenient to share the load and avoid overloading a specific instance globally."
msgstr "この戦略は、インスタンス間で負荷を均等に共有するものではありません。最悪の場合、ビジーなインスタンスを選んでしまう可能性があります。しかし、呼び出されたサービスが他のアプリケーション（ランダムロードバランシングも使用）でも使用されているとします。その場合、負荷を共有し、特定のインスタンスにグローバルに過負荷をかけないようにするのが便利な場合があります。"

#. type: Title ==
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:124
#, fuzzy
msgid "Least-Requests"
msgstr "最小要求数（Least-Requests"

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:126
#, fuzzy
msgid ""
"The two previous strategies do not monitor the invocations.\n"
"The _least-requests_ strategy does. When an instance is selected, it tracks the invocations, which counts the number of inflight requests in the case of this strategy.\n"
"When a call completes (successfully or not), it decrements the counter.\n"
"Thus, selecting an instance returns the instance with fewer inflight calls."
msgstr "前の2つの戦略は、起動を監視しない。 _最小リクエスト_ 戦略ではそうする。インスタンスが選択されると、呼び出しが追跡され、この戦略の場合、機内リクエストの数がカウントされる。呼び出しが完了すると（成功してもしなくても）、カウンターをデクリメントします。したがって、インスタンスを選択すると、インフライトコールが少ないインスタンスが返されます。"

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:201
#, fuzzy
msgid "To use this strategy, you need the following dependency:"
msgstr "このストラテジーを使用するためには、以下の依存関係が必要です："

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:141
#, fuzzy
msgid "You also need to configure the load balancer of your service:"
msgstr "また、サービスのロードバランサーを設定する必要があります："

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:148
#, fuzzy
msgid "If you call the service sequentially, it always picks the same instance:"
msgstr "サービスを順次呼び出すと、常に同じインスタンスを選びます："

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:152
#, fuzzy
msgid ""
"Indeed, the number of inflight requests for the service is always 0, as it waits for the response before calling it another time.\n"
"However, when you call the service concurrently, this strategy becomes a lot more relevant:"
msgstr "実際、サービスを呼び出す前に応答を待つので、サービスに対する機内リクエストの数は常に0です。しかし、サービスを同時並行で呼び出すと、この戦略はより意味を持つようになります："

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:157
#, fuzzy
msgid ""
"As the green service is the fastest, it gets called more frequently as inflight requests decrease quickly.\n"
"Thus, while the blue and yellow services still have inflight calls, the green service is back to 0 and selected."
msgstr "緑色のサービスは最も高速であるため、インフライトリクエストが急速に減少すると、より頻繁に呼び出されるようになります。したがって、ブルーとイエローのサービスにはまだインフライトコールがありますが、グリーンのサービスは0に戻り、選択されます。"

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:160
#, fuzzy
msgid ""
"This strategy is convenient when you have services with an API having different response times.\n"
"For example, you can have endpoints answering quickly and endpoints doing a lot more work, thus taking more time."
msgstr "この戦略は、APIを持つサービスが異なる応答時間を持つ場合に便利です。例えば、素早く応答するエンドポイントと、より多くの作業を行うエンドポイントがあり、より多くの時間がかかることがあります。"

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:163
#, fuzzy
msgid ""
"This strategy has one drawback.\n"
"If you have many service instances, you need to iterate over the whole set to find the one to pick."
msgstr "この方法には1つの欠点があります。多くのサービスインスタンスがある場合、選ぶべきものを見つけるためにセット全体を反復処理する必要があります。"

#. type: Title ==
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:166
#, fuzzy
msgid "The power of two random choices"
msgstr "ランダムな2つの選択の力"

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:168
#, fuzzy
msgid ""
"This strategy extends the _least-request_ one and addresses the drawback mentioned above.\n"
"Instead of iterating over the whole list of instances, it picks two instances randomly and selects the one with the fewer inflight requests."
msgstr "この戦略は、 _least-requestを_ 拡張し、上記の欠点に対処するものである。インスタンスのリスト全体を反復するのではなく、ランダムに2つのインスタンスを選び、機内リクエストの少ない方を選択するのである。"

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:181
#, fuzzy
msgid "You also need to configure the load balancer for the service:"
msgstr "また、サービス用のロードバランサーを設定する必要があります："

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:188
#, fuzzy
msgid "The results are similar to the _least-request_ as we have only three instances:"
msgstr "インスタンスが3つしかないため、結果は _least-requestと_ 同様です："

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:192
#, fuzzy
msgid ""
"However, this strategy is less expensive when you have many instances and when the iteration takes too much time.\n"
"In the worst case, it would pick the two most busy instances and select the one with fewer requests."
msgstr "しかし、この戦略は、インスタンスの数が多いときや、反復に時間がかかりすぎるときには、コストが低くなります。最悪の場合、最も忙しい2つのインスタンスを選び、リクエストの少ない方を選択することになります。"

#. type: Title ==
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:195
#, fuzzy
msgid "Least response time"
msgstr "最短の応答時間"

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:197
#, fuzzy
msgid ""
"The least response time keeps track of the response time and failures.\n"
"Thus, it selects the fastest instances.\n"
"That strategy handles failures by adding a penalty to failing instances."
msgstr "最小応答時間は、応答時間と失敗を記録しています。したがって、最も速いインスタンスを選択する。その戦略は、失敗したインスタンスにペナルティを追加することで失敗を処理する。"

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:211
#, fuzzy
msgid "You also need to configure the load-balancer for the service:"
msgstr "また、サービスのロードバランサーを設定する必要があります："

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:218
#, fuzzy
msgid ""
"This strategy selects the green instance more often.\n"
"However, due to the chance of failure, it will also pick the other ones once in a while."
msgstr "この戦略は、より頻繁に緑のインスタンスを選択します。しかし、失敗する可能性があるため、たまに他のインスタンスも選択します。"

#. type: Title ==
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:223
msgid "Summary"
msgstr "まとめ"

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:225
#, fuzzy
msgid ""
"This blog post has presented the load balancing strategies offered by Stork.\n"
"You can find the full list on http://smallrye.io/smallrye-stork/latest[the Stork web site]."
msgstr "このブログでは、Storkが提供するロードバランシング戦略についてご紹介しました。全リストはStorkの link:http://smallrye.io/smallrye-stork/latest[Web] サイトでご覧いただけます。"

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:228
#, fuzzy
msgid ""
"Strategies like `random` or `round-robin` allow dispatching the load between instances.\n"
"The `least-request`, `power-of-two-choices`, and `least-response-time` strategies monitor the calls to select the less loaded or fastest instance."
msgstr "`random` や `round-robin` のようなストラテジーは、インスタンス間で負荷を分散させることができます。 `least-request` 、 `power-of-two-choices` 、 `least-response-time` のストラテジーは、より負荷の少ない、または最も速いインスタンスを選択するために呼び出しを監視します。"

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:231
#, fuzzy
msgid "If these strategies do not fit your requirements, that's not a problem because http://smallrye.io/smallrye-stork/latest/load-balancer/custom-load-balancer/[you can implement your own] and craft the perfect selection algorithm."
msgstr "もし、これらのストラテジーがあなたの要求に合わない場合でも、 link:http://smallrye.io/smallrye-stork/latest/load-balancer/custom-load-balancer/[自分で実装] し、完璧な選択アルゴリズムを作り上げることができるので問題ないでしょう。"

#. type: Plain Text
#: upstream/_posts/2022-07-15-stork-load-balancing.adoc:233
#, fuzzy
msgid "You can also learn more about Stork and it integration in Quarkus in the http://smallrye.io/smallrye-stork/latest/quarkus/[Using Stork with Quarkus guide]."
msgstr "また、StorkとQuarkusの統合については、「 link:http://smallrye.io/smallrye-stork/latest/quarkus/[QuarkusでStorkを使用する」ガイドで] 詳しく説明しています。"

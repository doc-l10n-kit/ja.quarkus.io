msgid ""
msgstr ""
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: doc-l10n-kit"

#. type: YAML Front Matter
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:2
msgid "post"
msgstr "post"

#. type: YAML Front Matter
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:3
#, fuzzy
msgid "A IO thread and a worker thread walk into a bar: a microbenchmark story"
msgstr "IOスレッドとワーカースレッドがバーに入る：マイクロベンチマークの話"

#. type: YAML Front Matter
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:4
#, fuzzy
msgid "2020-04-21"
msgstr "2020-04-21"

#. type: YAML Front Matter
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:5
#, fuzzy
msgid "performance"
msgstr "パフォーマンス"

#. type: YAML Front Matter
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:6
#, fuzzy
msgid "Understand when and how to use the Quarkus IO thread and its influence on microbenchmarks."
msgstr "Quarkus IOスレッドを使用するタイミングや方法、マイクロベンチマークへの影響について理解することができます。"

#. type: YAML Front Matter
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:7
#, fuzzy
msgid "ebernard"
msgstr "エーベルナール"

#. type: Plain Text
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:11
#, fuzzy
msgid ""
"A competitor recently published a microbenchmark comparing the performance of their stack to Quarkus.\n"
"The Quarkus team feels this microbenchmark shouldn’t be taken at face value because it wasn’t making a like-to-like comparison leading to incorrect conclusions.\n"
"Both of the two frameworks under comparison support reactive processing.\n"
"Reactive processing enables running the business logic directly on the _IO thread_, which ultimately performs better in microbenchmark focusing on response time and concurrency.\n"
"The microbenchmark should have been written so that both frameworks (or neither framework) obtain this benefit.\n"
"Anyway, this turns out to be a very interesting topic and good information for Quarkus users, so read on."
msgstr "競合他社が最近、自社のスタックとQuarkusのパフォーマンスを比較するマイクロベンチマークを公開しました。Quarkusチームは、このマイクロベンチマークを額面通りに受け取るべきでないと考えています。というのも、同種の比較をしていなかったため、誤った結論に至ってしまったからです。比較対象となった2つのフレームワークは、どちらもリアクティブ処理をサポートしています。リアクティブ処理では、ビジネスロジックを _IOスレッドで_ 直接実行できるため、レスポンスタイムと同時実行性に焦点を当てたマイクロベンチマークでは、最終的にパフォーマンスが向上します。本来であれば、どちらのフレームワークでも（あるいはどちらのフレームワークでも）このメリットが得られるように、マイクロベンチマークを記述する必要があります。いずれにせよ、これは非常に興味深いトピックであり、Quarkusユーザーにとって良い情報であることが判明しました。"

#. type: Title ==
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:18
#, fuzzy
msgid "tl; dr;"
msgstr "tl; dr；"

#. type: Plain Text
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:20
#, fuzzy
msgid ""
"Quarkus https://quarkus.io/blog/runtime-performance/[has great performance] for both imperative and reactive workloads.\n"
"It’s because Quarkus is itself based on Eclipse Vert.x, a mature top performing reactive framework, in such a way that allows you to layer, mix and match the IO paradigm that best fits your use-case."
msgstr "Quarkusは、命令型と反応型の両方のワークロードで link:https://quarkus.io/blog/runtime-performance/[優れた性能を] 発揮します。Quarkusは、成熟した最高性能のリアクティブフレームワークであるEclipse Vert.xをベースにしているため、ユースケースに最も適したIOパラダイムを重ねたり、組み合わせたり、マッチさせたりすることができます。"

#. type: Plain Text
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:23
#, fuzzy
msgid "If you have a REST scenario well suited to run _purely on the IO thread_, add a Vert.x Reactive Route using https://quarkus.io/guides/reactive-routes[Quarkus Reactive Routes] and your app will get better performance than using Quarkus RESTEasy."
msgstr "RESTシナリオを _純粋にIOスレッドで_ 実行するのに適している場合、 link:https://quarkus.io/guides/reactive-routes[Quarkus Reactive Routesを] 使用してVert.x Reactive Routeを追加すると、Quarkus RESTEasyを使用するよりもアプリのパフォーマンスが向上します。"

#. type: Plain Text
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:25
#, fuzzy
msgid ""
"We ran this low-work REST + validation competitor-written microbenchmark which features no blocking operation, just returning static data.\n"
"When using Quarkus Reactive Routes to run Quarkus _purely on the IO thread_, **we observed 2.6x times the requests/sec and 30% less memory usage (RSS)** than running with Quarkus RESTEasy (which mixes IO thread and worker thread).\n"
"But that’s on a microbenchmark purpose built to this specific scenario (more on that later)."
msgstr "ブロック操作を行わず、静的なデータを返すことを特徴とする、この低作業REST + 検証競合他社が作成したマイクロベンチマークを実行しました。Quarkus Reactive Routesを使用してQuarkusを _純粋にIOスレッドで_ 実行すると、Quarkus RESTEasy（IOスレッドとワーカースレッドが混在）を使用する場合と比べて、 *リクエスト/秒が2.6倍、メモリ使用量が30%少なくなりました（RSS）* 。しかし、これはこの特定のシナリオのために作られたマイクロベンチマークでの結果です（詳細は後述します）。"

#. type: Title ==
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:31
#, fuzzy
msgid "More interesting read"
msgstr "より興味深い読み物"

#. type: Plain Text
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:33
#, fuzzy
msgid ""
"The microbenchmark itself is uninteresting, but it is a good demonstrator of a phenomenon that can happen in reactive stacks.\n"
"Let’s use it as a vehicle to learn more about Quarkus and its reactive engine."
msgstr "このマイクロベンチマーク自体は面白くないのですが、リアクティブスタックで起こりうる現象を示す良いデモです。Quarkusとそのリアクティブエンジンについてもっと知るための手段として、このベンチマークを使ってみましょう。"

#. type: Title ===
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:36
msgid "Imperative and Reactive: the elevator pitch"
msgstr "命令型とリアクティブ型: エレベーターピッチ"

#. type: Plain Text
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:38
#, fuzzy
msgid ""
"This blog post does not explain the fundamental differences between the imperative execution model and the reactive execution model.\n"
"However, to understand why we see so much difference in the mentioned microbenchmark, we need some notions."
msgstr "このブログ記事では、命令型実行モデルと反応型実行モデルの根本的な違いについては説明しません。しかし、言及したマイクロベンチマークでなぜこれほどの違いが見られるのかを理解するためには、いくつかの概念が必要です。"

#. type: Plain Text
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:41
#, fuzzy
msgid ""
"In general, Java web applications use imperative programming combined with blocking IO operations.\n"
"This is incredibly popular because it is easier to reason about the code.\n"
"_Things_ get executed sequentially.\n"
"To make sure one request is not affected by another, they are run on different threads.\n"
"When your workload needs to interact with a database or another remote service, it relies on blocking IO.\n"
"The thread is blocked waiting for the answer.\n"
"Other requests running on different threads are not slowed down significantly.\n"
"But this means one thread for every concurrent request, which limits the overall concurrency."
msgstr "一般に、Javaウェブアプリケーションでは、命令型プログラミングとブロッキングIOオペレーションを組み合わせて使用します。これは、コードの推論が容易であるため、非常に人気があります。 _物事は_ 順番に実行されます。あるリクエストが他のリクエストの影響を受けないようにするために、これらのリクエストは異なるスレッドで実行されます。ワークロードがデータベースや他のリモートサービスとやり取りする必要がある場合、ブロッキングIOに依存します。スレッドは、回答を待ってブロックされます。異なるスレッドで実行されている他のリクエストは、大きく減速されることはありません。しかし、これはすべての同時リクエストに対して1つのスレッドを意味し、全体の同時性を制限することになります。"

#. type: Plain Text
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:50
#, fuzzy
msgid ""
"On the other side, the reactive execution model embraces asynchronous development models and non blocking IOs.\n"
"With this model, multiple requests can be handled by the same thread.\n"
"When the processing of a request cannot make progress anymore (because it requests a remote service, or interacts with a database), it uses non blocking IO.\n"
"This releases the thread immediately, which can then be used to serve another request.\n"
"When the result of the IO operation is available, the processing of the request is restored and continues its execution.\n"
"This model enables the usage of the _IO thread_ to handle multiple requests.\n"
"There are two significant benefits.\n"
"First, the response time is smaller because it does not have to jump to another thread.\n"
"Second, it reduces memory consumption as it decreases the usage of threads.\n"
"The reactive model uses the hardware resources more efficiently, but... there is a significant drawback.\n"
"If the processing of a request starts to block, this gets real bad.\n"
"No other request can be handled.\n"
"To avoid this, you need to learn how to write non blocking code, how to structure asynchronous processing, and how to use non blocking IOs.\n"
"It's a paradigm shift."
msgstr "一方、リアクティブ実行モデルは、非同期開発モデルやノンブロッキングIOを包含しています。このモデルでは、複数のリクエストを同じスレッドで処理することができます。リクエストの処理がこれ以上進まない場合（リモートサービスを要求したり、データベースとやりとりするため）、ノンブロッキングIOを使用します。これにより、スレッドは直ちに解放され、別のリクエストの処理に使用できるようになります。IO操作の結果が利用可能になると、リクエストの処理は復元され、実行が継続されます。このモデルでは、 _IOスレッドを_ 使用して複数のリクエストを処理することができます。2つの大きな利点があります。第一に、他のスレッドにジャンプする必要がないため、応答時間が小さくなる。第二に、スレッドの使用量が減るため、メモリ消費量が減少します。リアクティブモデルは、ハードウェアリソースをより効率的に使用しますが、...重大な欠点があります。リクエストの処理がブロックされ始めると、これは本当にまずいことになります。他のリクエストは処理できなくなります。これを避けるには、ブロッキングしないコードの書き方、非同期処理の構造、ブロッキングしないIOの使い方を学ぶ必要があります。これはパラダイムシフトなのです。"

#. type: Plain Text
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:65
#, fuzzy
msgid ""
"In Quarkus, we want to make the shift as easy as possible.\n"
"However, we have observed that the majority of user applications are written using the imperative model.\n"
"That is why, when the user application uses JAX-RS, Quarkus defaults to execute the (imperative) workload to a _worker thread_."
msgstr "Quarkusでは、この移行を可能な限り簡単にしたいと考えています。しかし、ユーザーアプリケーションの大半は命令型モデルを使って書かれていることが確認されています。そのため、ユーザーアプリケーションがJAX-RSを使用する場合、Quarkusはデフォルトで（命令型）ワークロードを _ワーカースレッドに_ 実行するようになっています。"

#. type: Title ===
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:69
#, fuzzy
msgid "Hello world microbenchmark: IO thread or worker thread?"
msgstr "Hello world マイクロベンチマーク：IOスレッドかワーカースレッドか？"

#. type: Plain Text
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:71
#, fuzzy
msgid ""
"Back to the competitor’s microbenchmark, we have a REST endpoint doing some trivial processing and some equally trivial validation.\n"
"Pretty much no meaningful business work.\n"
"This is the Hello World of REST for all intents and purposes."
msgstr "競合他社のマイクロベンチマークに戻ると、RESTエンドポイントにつまらない処理と同じくつまらない検証をさせています。意味のあるビジネス作業はほとんどありません。これは、どう考えてもRESTのHello Worldです。"

#. type: Plain Text
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:75
#, fuzzy
msgid ""
"When you run the microbenchmark with Quarkus RESTEasy, the request is handled by the reactive engine on the _IO thread_ but then the processing work is handed over to a second thread from the _worker thread pool_.\n"
"That’s called _dispatch_.\n"
"When your microbenchmark does as little as Hello World, then the dispatch overhead is proportionally big.\n"
"The dispatch overhead is not visible in most (real life) applications but is very visible in artificial constructs like microbenchmarks."
msgstr "Quarkus RESTEasyでマイクロベンチマークを実行すると、リクエストは _IOスレッド_ 上のreactiveエンジンで処理されますが、その後、処理作業は _ワーカースレッドプールから_ 2番目のスレッドに引き渡されます。これを _ディスパッチと_ 呼びます。マイクロベンチマークがHello Worldのような小さな処理を行う場合、ディスパッチのオーバーヘッドもそれに比例して大きくなります。ディスパッチのオーバーヘッドは、ほとんどの（現実の）アプリケーションでは見えませんが、マイクロベンチマークのような人工的な構成では非常によく見えます。"

#. type: Plain Text
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:80
#, fuzzy
msgid ""
"The competitor’s stack, however, runs all the request operations on the IO thread by default.\n"
"So what this microbenchmark was actually comparing is just the cost of dispatching to the worker thread pool.\n"
"And frankly (according to the competitor's numbers) and in spite of this extra dispatch work, Quarkus did very very well achieving ~95% of the competitor’s throughput today!  I say today because we are always improving upon performance, and in fact we expect to see further gains in the soon to be released 1.4 release."
msgstr "しかし、競合他社のスタックは、デフォルトですべてのリクエスト処理をIOスレッドで実行する。つまり、このマイクロベンチマークが実際に比較しているのは、ワーカースレッドプールへのディスパッチコストだけなのです。そして率直に言って（競合の数字によると）、この余分なディスパッチ作業にもかかわらず、Quarkusは今日、競合のスループットの～95%を達成し、非常にうまくいきました！というのも、Quarkusは常にパフォーマンスを向上させており、間もなくリリースされる1.4リリースではさらなる向上が見込まれるからです。"

#. type: Plain Text
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:84
#, fuzzy
msgid "*When compared at a disadvantage (dispatching to a worker thread), Quarkus is nevertheless almost as fast in throughput.*"
msgstr "*不利な条件（ワーカースレッドへのディスパッチ）で比較すると、それでもQuarkusのスループットはほぼ同等に速い。*"

#. type: Plain Text
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:86
#, fuzzy
msgid ""
"… But wait, Quarkus can also avoid the dispatch altogether and run operations on the IO Thread.\n"
"This is a more accurate comparison to how the competitor' stack was configured to do as in both case, it is the user's responsibility to ask for a dispatch if and when needed by the application.\n"
"To compare apples to apples, let’s use https://quarkus.io/guides/reactive-routes[Quarkus Reactive Routes] backed by Eclipse Vert.x.\n"
"In this model, operations are run on the IO thread by default."
msgstr "しかし、Quarkusはディスパッチを完全に回避して、IOスレッドで処理を実行することもできます。どちらの場合も、アプリケーションが必要なときにディスパッチを要求するのはユーザーの責任であるため、競合他社のスタックがどのように構成されていたかをより正確に比較することができるのです。このモデルでは、操作はデフォルトでIOスレッドで実行されます。"

#. type: Plain Text
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:124
#, fuzzy
msgid "This is not very different from your JAX-RS equivalent."
msgstr "これはJAX-RSに相当するものと大差はありません。"

#. type: Title ===
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:126
#, fuzzy
msgid "Throughput Numbers"
msgstr "スループット数"

#. type: Plain Text
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:128
#, fuzzy
msgid "We ran the microbenchmark application in a docker container constrained to reflect a typical resource allocation to a container orchestrated by Kubernetes:"
msgstr "Kubernetesでオーケストレーションされたコンテナへの典型的なリソース割り当てを反映するように制約されたDockerコンテナで、マイクロベンチマークアプリケーションを実行しました："

#. type: Plain Text
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:130
#, fuzzy
msgid "4 CPU"
msgstr "4 CPU"

#. type: Plain Text
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:131
#, fuzzy
msgid "256 MB of RAM"
msgstr "256 MBのRAM"

#. type: Plain Text
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:132
#, fuzzy
msgid "and `-Xmx128m` heap usage for the Java process"
msgstr "と `-Xmx128m` Javaプロセスのヒープ使用率"

#. type: Plain Text
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:134
#, fuzzy
msgid ""
"We saw that Quarkus using Reactive Routes ran 2.6 times the requests/sec.\n"
"2.6 times!\n"
"It makes sense! Remember the application code virtually does nothing, so the dispatch cost is comparatively high.\n"
"If you were to write a more real life workload (maybe even having a blocking operation like a JPA access and therefore forcing a dispatch), then the results would be very different.\n"
"Context matters!"
msgstr "Reactive Routesを使用したQuarkusは、2.6倍のリクエスト/秒を実行していることがわかりました。2.6倍です！これは理にかなっています！アプリケーションコードは事実上何もしないので、ディスパッチコストは比較的高いことを思い出してください。もし、もっと現実的なワークロードを書いたとしたら（JPAアクセスのようなブロッキング操作があり、ディスパッチを強いられるかもしれません）、結果は大きく異なることでしょう。コンテキストが重要なのです！"

#. type: Plain Text
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:140
#, fuzzy
msgid "You can find code and how to reproduce the microbenchmark https://github.com/johnaohara/quarkus-iothread-workerpool/tree/1.3.1.Final[here on GitHub]."
msgstr "マイクロベンチマークのコードと再現方法は、 link:https://github.com/johnaohara/quarkus-iothread-workerpool/tree/1.3.1.Final[GitHubの] こちらに掲載されています。"

#. type: Title ===
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:142
#, fuzzy
msgid "Microbenchmark results comparing Quarkus dispatching to a worker thread vs running purely on the IO thread"
msgstr "Quarkusがワーカースレッドにディスパッチする場合と、純粋にIOスレッドで実行する場合を比較したマイクロベンチマークの結果"

#. type: Table
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:145
#, fuzzy
msgid "Quarkus - 1.3.1.Final - 4 CPU's"
msgstr "Quarkus - 1.3.1.Final - 4CPU"

#. type: Table
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:146
msgid "Worker thread"
msgstr "ワーカースレッド"

#. type: Table
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:147
#, fuzzy
msgid "IO thread"
msgstr "IOスレッド"

#. type: Table
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:148
#, fuzzy
msgid "Ratio"
msgstr "比率"

#. type: Table
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:150
#, fuzzy
msgid "Mean Start Time to First Request (ms) footnote:[‘Mean Start Time to First Request’ was measured using an application built as an UberJar]"
msgstr "最初のリクエストまでの平均開始時間（ms）[ link:[1］, id=\"_footnoteref_1\", class=\"footnote\", href=\"#_footnotedef_1\", title=\"View footnote.\"]"

#. type: Table
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:151
#, fuzzy
msgid "993.9"
msgstr "993.9"

#. type: Table
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:152
#, fuzzy
msgid "868.3"
msgstr "868.3"

#. type: Table
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:153
#, fuzzy
msgid "87.4%"
msgstr "87.4%"

#. type: Table
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:155
#, fuzzy
msgid "Max RSS (MB)"
msgstr "最大RSS数(MB)"

#. type: Table
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:156
#, fuzzy
msgid "138.8"
msgstr "138.8"

#. type: Table
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:157
#, fuzzy
msgid "97.9"
msgstr "97.9"

#. type: Table
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:158
#, fuzzy
msgid "70.5%"
msgstr "70.5%"

#. type: Table
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:160
#, fuzzy
msgid "Max Throughput (req/sec)"
msgstr "最大スループット（req/sec）"

#. type: Table
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:161
#, fuzzy
msgid "46,172.2"
msgstr "46,172.2"

#. type: Table
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:162
#, fuzzy
msgid "123,520.4"
msgstr "123,520.4"

#. type: Table
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:163
#, fuzzy
msgid "267.5%"
msgstr "267.5%"

#. type: Table
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:165
#, fuzzy
msgid "Max Req/Sec/MB"
msgstr "最大Req/秒/MB"

#. type: Table
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:166
#, fuzzy
msgid "332.7"
msgstr "332.7"

#. type: Table
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:167
#, fuzzy
msgid "1,262.1"
msgstr "1,262.1"

#. type: Table
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:168
#, fuzzy
msgid "379.4%"
msgstr "379.4%"

#. type: Plain Text
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:173
#, fuzzy
msgid "*In a fair comparison (purely remaining on the IO thread - no dispatch), Quarkus more than double its throughput.*"
msgstr "*公正な比較（純粋にIOスレッドにとどまり、ディスパッチなし）では、Quarkusのスループットは2倍以上である。*"

#. type: Plain Text
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:175
#, fuzzy
msgid ""
"As the generated load tends towards the maximum throughput of the system under test, the response time experienced by the client increases exponentially.\n"
"So the best system (for the workload) has a vertical line as far to the right as possible.\n"
"Equally important is to have as flat a line as possible for the longest time.\n"
"You do not want the response time to degrade before the system reaches maximum throughput."
msgstr "生成された負荷がテスト対象システムの最大スループットに向かうにつれ、クライアントが経験する応答時間は指数関数的に増加します。つまり、（作業負荷に対して）最適なシステムは、垂直線が可能な限り右側にあるのです。同様に重要なのは、長い時間、できるだけ平坦な線であることです。システムが最大スループットに達する前にレスポンスタイムが低下するのは避けたいところです。"

#. type: Plain Text
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:182
#, fuzzy
msgid ""
"By the way, in the competitor microbenchmark Quarkus is shown as consuming more RSS (more RAM).This is also explained by the worker thread pool being operated whereas the competitor did not have a worker thread pool.\n"
"The Quarkus Reactive Routes solution (on a pure IO event run) shows a 30% RSS usage reduction."
msgstr "これは、競合他社がワーカースレッドプールを持たないのに対し、Quarkusはワーカースレッドプールを運用していたためと考えられます。Quarkus Reactive Routesソリューション（純粋なIOイベント実行時）では、RSS使用量が30%削減されています。"

#. type: Plain Text
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:187
#, fuzzy
msgid ""
"In this graph, the lower, the better.\n"
"We see that the pure IO thread solution manages to increase throughput with little to no change to the memory usage (RSS), that's very good!"
msgstr "このグラフでは、低ければ低いほど良いということになります。純粋なIOスレッドソリューションは、メモリ使用量（RSS）にほとんど変化を与えずにスループットを向上させることに成功していることがわかりますが、これは非常に良いことです！"

#. type: Title ==
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:190
msgid "Conclusion"
msgstr "まとめ"

#. type: Plain Text
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:192
#, fuzzy
msgid ""
"Quarkus offers you the ability to safely run blocking operations, run non blocking operations on the IO thread or mix both models.\n"
"The Quarkus team takes performance very seriously and we see Quarkus as offering great numbers whether you use the imperative or reactive models.\n"
"In more realistic workloads, the dispatch cost would be much less significant, you would not see such drastic differences between the two approaches.\n"
"As usual, test as close to your real application as possible."
msgstr "Quarkusでは、ブロッキング処理を安全に実行したり、IOスレッドでノンブロッキング処理を実行したり、両方のモデルを混在させたりすることが可能です。Quarkusチームはパフォーマンスを非常に重要視しており、Quarkusは命令型モデルでも反応型モデルでも、素晴らしい数値を提供すると考えています。より現実的なワークロードでは、ディスパッチコストはそれほど重要ではなく、2つのアプローチでこれほど劇的な差は見られないでしょう。いつものように、できるだけ実際のアプリケーションに近い形でテストしてください。"

#. type: Plain Text
#: upstream/_posts/2020-04-21-io-thread-benchmark.adoc:197
#, fuzzy
msgid ""
"Mystery solved.\n"
"Benchmarks are hard, challenge them.\n"
"But the moral of the story is that in all bad comes some good.\n"
"We’ve now learned how to run Quarkus applications entirely on the IO thread.\n"
"And how in some situations that can make a big difference.\n"
"Remember, don’t block! In fact, Quarkus https://quarkus.io/guides/all-config#quarkus-vertx-core_quarkus.vertx.warning-exception-time[can warn you if you do so].\n"
"Oh and we also learned that Quarkus is so fast, it can even beat itself ;p"
msgstr "謎が解けた。ベンチマークは難しい、挑戦せよ。しかし、この話の教訓は、すべての悪いことには良いことがあるということです。Quarkusアプリケーションを完全にIOスレッドで実行する方法について学びました。そして、状況によっては、それが大きな違いになることもあるのです。覚えておいてほしいのは、ブロックしてはいけないということです！実際、ブロックするとQuarkusは link:https://quarkus.io/guides/all-config#quarkus-vertx-core_quarkus.vertx.warning-exception-time[警告を] 発します。また、Quarkusは非常に高速で、自分自身を打ち負かすことさえできることも学びました。"

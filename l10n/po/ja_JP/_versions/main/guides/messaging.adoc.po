msgid ""
msgstr ""
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: jekyll-l10n\n"

#: _versions/main/guides/messaging.adoc
msgid "Quarkus Messaging Extensions"
msgstr "Quarkus Messagingエクステンション"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"Event-driven messaging systems have become the backbone of most modern applications,\n"
"enabling the building of message-driven microservices or complex data streaming pipelines."
msgstr "イベント駆動型のメッセージングシステムは、ほとんどの最新アプリケーションのバックボーンとなっており、メッセージ駆動型のマイクロサービスや複雑なデータストリーミングパイプラインの構築を可能にしています。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"Quarkus offers a comprehensive suite of messaging extensions designed to synchronize with leading messaging technologies effortlessly.\n"
"This empowers developers to concentrate on crafting the core application logic, liberating them from the necessity to delve into the complexities of individual APIs and messaging infrastructures."
msgstr "Quarkusは、主要なメッセージングテクノロジーと容易に同期できるように設計された、メッセージング拡張機能の包括的なスイートを提供します。これにより、開発者は、個々のAPIやメッセージングインフラストラクチャの複雑さを理解する必要から解放され、コアアプリケーションロジックの作成に集中することができます。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "This page focuses on common features and the development model for all messaging extensions."
msgstr "このページでは、すべてのメッセージング拡張機能に共通する機能と開発モデルに焦点を当てます。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Some of these extensions are maintained in the core Quarkus repository:"
msgstr "これらの拡張機能の一部は、Quarkusのコアリポジトリで管理されています："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "*Messaging*: The core extension defines the basic concepts and APIs to develop messaging applications"
msgstr "*メッセージング* ：コアエクステンションは、メッセージングアプリケーションを開発するための基本的な概念とAPIを定義します。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "xref:kafka.adoc[*Messaging - Kafka Connector*]"
msgstr "xref:kafka.adoc[メッセージング - Kafka コネクタ]"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "xref:pulsar.adoc[*Messaging - Pulsar Connector*]"
msgstr "xref:pulsar.adoc[メッセージング - Pulsar Connector]"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "xref:rabbitmq-reference.adoc[*Messaging - RabbitMQ Connector*]"
msgstr "xref:rabbitmq-reference.adoc[メッセージング - RabbitMQコネクタ]"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "xref:amqp-reference.adoc[*Messaging - AMQP 1.0 Connector*]"
msgstr "xref:amqp-reference.adoc[メッセージング - AMQP 1.0 コネクタ]"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "*Messaging - MQTT Connector*"
msgstr "*メッセージング - MQTTコネクタ*"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Some extensions are contributed and maintained by the community:"
msgstr "いくつかの拡張機能はコミュニティによって寄稿され、メンテナンスされています："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "link:{camel-smallrye-reactive-messaging}[Camel Smallrye Reactive Messaging]"
msgstr "link:{camel-smallrye-reactive-messaging}[キャメル・スモールリー・リアクティブ・メッセージング]"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "link:{nats-jetstream}[Nats Jetstream Connector]"
msgstr "link:{nats-jetstream}[ナッツ・ジェットストリーム・コネクター]"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "link:{solace-quarkus}[Solace Messaging Connector]"
msgstr "link:{solace-quarkus}[Solace メッセージング・コネクタ]"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "link:{http-websocket-connector}[Reactive HTTP and WebSocket Connector]"
msgstr "link:{http-websocket-connector}[リアクティブHTTPおよびWebSocketコネクタ]"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "AWS SQS Connector"
msgstr "AWS SQS コネクタ"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Other connectors, such as the *JMS Connector* or the *Google PubSub Connector*, do not benefit from the same level of integration and require more manual configuration to set up."
msgstr "*JMS Connectorや* *Google PubSub Connectorの* ような他のコネクタは、同じレベルの統合の恩恵を受けておらず、セットアップにはより多くの手動設定が必要です。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"On the other hand, some messaging-related extensions propose low-level provider-specific integrations.\n"
"The level of support covered on this page DOES NOT involve these low-level extensions.\n"
"A non-exhaustive list of this kind of extension are the following:"
msgstr "一方、メッセージング関連の拡張の中には、低レベルのプロバイダ固有の統合を提案するものもあります。このページで扱うサポートレベルには、このような低レベルの拡張は含まれません。この種の拡張の非網羅的なリストは以下のとおりです："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "link:https://quarkus.io/guides/kafka-streams[Kafka Streams Extension]"
msgstr "link:https://quarkus.io/guides/kafka-streams[Kafkaストリーム拡張]"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "link:https://docs.quarkiverse.io/quarkus-rabbitmq-client/dev/index.html[RabbitMQ Client]"
msgstr "link:https://docs.quarkiverse.io/quarkus-rabbitmq-client/dev/index.html[RabbitMQクライアント]"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "link:https://docs.quarkiverse.io/quarkus-hivemq-client/dev/index.html[HiveMQ Client]"
msgstr "link:https://docs.quarkiverse.io/quarkus-hivemq-client/dev/index.html[HiveMQ クライアント]"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "link:https://docs.quarkiverse.io/quarkus-artemis/dev/quarkus-artemis-jms.html[Artemis Core & JMS]"
msgstr "link:https://docs.quarkiverse.io/quarkus-artemis/dev/quarkus-artemis-jms.html[アルテミス・コアとJMS]"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "link:https://docs.quarkiverse.io/quarkus-google-cloud-services/main/pubsub.html[Google Cloud Pubsub]"
msgstr "link:https://docs.quarkiverse.io/quarkus-google-cloud-services/main/pubsub.html[Google Cloud Pubsub]"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Quarkus Messaging Development Model"
msgstr "Quarkusメッセージング開発モデル"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"Quarkus simplifies message-driven application development by establishing a uniform model for publishing, consuming, and processing messages, regardless of whether the underlying broker technology uses message queuing or event streaming.\n"
"Built upon the MicroProfile Reactive Messaging specification, Quarkus Messaging extensions ensure seamless integration with these technologies.\n"
"Importantly, proficiency in reactive programming is NOT a prerequisite for leveraging these capabilities."
msgstr "Quarkusは、基盤となるブローカーテクノロジーがメッセージキューイングまたはイベントストリーミングのどちらを使用しているかに関係なく、メッセージの発行、消費、処理のための統一されたモデルを確立することによって、メッセージ駆動型のアプリケーション開発を簡素化します。MicroProfile Reactive Messaging仕様に基づいて構築されたQuarkusのメッセージング拡張機能は、これらのテクノロジーとのシームレスな統合を保証します。重要なのは、リアクティブプログラミングに習熟していることは、これらの機能を活用するための前提条件ではないということです。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"The Reactive Messaging specification defines a CDI-based programming model for implementing event-driven and message-driven applications.\n"
"Using a small set of annotations, CDI beans become building blocks for implementing interactions with message brokers.\n"
"These interactions happen through _channels_ where application components read and write messages."
msgstr "Reactive Messaging仕様は、イベント駆動型アプリケーションとメッセージ駆動型アプリケーションを実装するためのCDIベースのプログラミングモデルを定義します。アノテーションの小さなセットを使用して、CDI Beanはメッセージブローカーとの相互作用を実装するためのビルディングブロックになります。これらのやり取りは、アプリケーションコンポーネントがメッセージを読み書きする _チャネルを通して_ 行われます。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "_Channels_ are identified by a unique name and declared using a set of annotations."
msgstr "_チャンネルは_ 一意の名前で識別され、一連のアノテーションを使って宣言されます。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "`@Incoming` and `@Outgoing` annotations"
msgstr "`@Incoming` および 注釈 `@Outgoing` "

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "`@Incoming` and `@Outgoing` method annotations define _channels_ allowing to consume messages from and produce messages to the message broker:"
msgstr "`@Incoming` および メソッドアノテーションは、メッセージブローカーからメッセージを消費し、メッセージブローカーにメッセージを生成する `@Outgoing` _チャネルを_ 定義します："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "`@Outgoing` can be used by itself on a method to generate messages:"
msgstr "`@Outgoing` はメッセージを生成するメソッドで単独で使うことができます："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "`@Incoming` can be used by itself to consume messages:"
msgstr "`@Incoming` はそれ自体でメッセージを消費することができます："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"Note that you should not call methods annotated with `@Incoming` and/or `@Outgoing` directly from your code.\n"
"They are invoked by the framework.\n"
"Having user code invoking them would not have the expected outcome."
msgstr "`@Incoming` や `@Outgoing` でアノテーションされたメソッドを、コードから直接呼んではいけません。これらはフレームワークによって呼び出されます。ユーザーコードがこれらを呼び出すことは、期待された結果をもたらしません。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "You can read more on supported method signatures in the link:{rm_doc_method_signatures}[SmallRye Reactive Messaging – Supported signatures]."
msgstr "サポートされるメソッド・シグネチャの詳細については、 link:{rm_doc_method_signatures}[SmallRye Reactive Messaging - サポートされるシグネチャを] 参照してください。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Emitters and `@Channel` annotation"
msgstr "エミッターと `@Channel` 注釈"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "An application often needs to combine messaging with other parts of the application, ex. produce messages from HTTP endpoints, or stream consumed messages as a response."
msgstr "例えば、HTTPエンドポイントからメッセージを生成したり、レスポンスとして消費されたメッセージをストリーミングしたり。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "To send messages from imperative code to a specific channel, you need to inject an `Emitter` object identified by the `@Channel` annotation:"
msgstr "命令型コードから特定のチャネルにメッセージを送信するには、 `@Channel` アノテーションで識別される `Emitter` オブジェクトを注入する必要があります："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"The `@Channel` annotation lets you indicate to which channel you will send your payloads or messages.\n"
"The `Emitter` allows buffering messages sent to the channel."
msgstr "`@Channel` アノテーションを使用すると、ペイロードやメッセージをどのチャネルに送 信するかを指定できます。 `Emitter` を使うと、チャネルに送られたメッセージをバッファリングできます。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "For more control, using link:{mutiny}[Mutiny] APIs, you can use the `MutinyEmitter` emitter interface:"
msgstr "link:{mutiny}[Mutinyの] APIを使ってよりコントロールするには、 `MutinyEmitter` エミッター・インターフェースを使います："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "The `@Channel` annotation can also be used to inject the stream of messages from an incoming channel:"
msgstr "`@Channel` アノテーションは、着信チャンネルからメッセージのストリームを注入するために使用することもできます："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"When consuming messages with `@Channel`, the application code is responsible for subscribing to the stream.\n"
"In the example above, the Quarkus REST (formerly RESTEasy Reactive) endpoint handles that for you."
msgstr "`@Channel` を使用してメッセージを消費する場合、アプリケーションコードはストリームの購読を担当します。上記の例では、Quarkus REST（旧RESTEasy Reactive）エンドポイントがこれを処理します。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "You can read more on the emitters and channels in the link:{rm_doc_emitter}[SmallRye Reactive Messaging – Emitter and Channels] documentation."
msgstr "エミッタとチャネルの詳細については、 link:{rm_doc_emitter}[SmallRye Reactive Messaging - Emitter and Channelsの] ドキュメントを参照してください。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Messages and Metadata"
msgstr "メッセージとメタデータ"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"A `Message` is an envelope around a payload.\n"
"In the examples above only payloads were used, but every payload is wrapped around a `Message` internally in Quarkus Messaging."
msgstr "`Message` は、ペイロードを包むエンベロープです。上記の例ではペイロードのみが使用されていますが、Quarkus Messagingでは内部的にすべてのペイロードが `Message` 。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"The `Message<T>` interface associates a payload of type `<T>` with `Metadata`,\n"
"a set of arbitrary objects and asynchronous actions for acknowledgement (ack) and negative acknowledgement (nack)."
msgstr "`Message<T>` インターフェースは、 `<T>` 型のペイロードと、 `Metadata` 、任意のオブジェクトのセット、および確認応答（ack）と否定応答（nack）の非同期アクションを関連付けます。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"A message is acknowledged back to the broker when its processing or reception has been successful.\n"
"Acknowledgements between messages are chained, meaning that when processing a message,\n"
"the acknowledgement of an outgoing message triggers the acknowledgement of incoming message(s).\n"
"In most cases, acks and nacks are managed for you and connectors allow you to configure different strategies per channel.\n"
"So, you usually don't need to interact with the `Message` interface directly.\n"
"Only advanced use cases require dealing with the Message directly."
msgstr "メッセージの処理または受信が成功すると、ブローカーに確認応答が返されます。メッセージ間の確認応答は連鎖します。つまり、メッセージを処理する際に、送信メッセージの確認応答が受信メッセージの確認応答をトリガーするということです。ほとんどの場合、acks と nacks はあなたのために管理され、コネクターによってチャンネルごとに異なるストラテジーを設定することができます。そのため、通常は `Message` インタフェースを直接操作する必要はありません。メッセージを直接扱う必要があるのは、高度なユースケースだけです。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"Accessing the `Metadata`, on the other hand, can be practical in many cases.\n"
"Connectors add specific metadata objects to the message to give access to the message headers, properties, and other connector-specific information.\n"
"You do not need to interact with the `Message` interface to access connector-specific metadata.\n"
"You can simply inject the metadata object as a method parameter after the payload parameter:"
msgstr "一方、 `Metadata` へのアクセスは、多くの場合に実用的です。コネクタは、メッセージに特定のメタデータ・オブジェクトを追加して、メッセージ・ ヘッダやプロパティ、その他のコネクタ固有の情報にアクセスできるようにします。コネクタ固有のメタデータにアクセスするために、 `Message` インタ フェースとやり取りする必要はありません。ペイロードパラメータの後にメソッドパラメータとしてメタデータオブジェクトを注入するだけです："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"Depending on the connector, payload types available to consume in processing methods differ.\n"
"You can implement a custom `MessageConverter` to transform the payload to a type that is accepted by your application."
msgstr "コネクタによって、処理メソッドで使用できるペイロードのタイプは異なります。カスタム `MessageConverter` を実装して、ペイロードをアプリケーションで受け入れられる型に変換できます。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Channel configuration"
msgstr "チャンネル構成"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Channel attributes can be configured using the `mp.messaging.incoming.<channel-name>` and `mp.messaging.outgoing.<channel-name>` configuration properties."
msgstr "チャンネル属性は、 `mp.messaging.incoming.<channel-name>` と `mp.messaging.outgoing.<channel-name>` 設定プロパティを使用して設定できます。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "For example, to configure the Kafka connector to consume messages from the `my-topic` topic with a custom deserializer:"
msgstr "たとえば、 `my-topic` トピックからカスタムデシリアライザでメッセージを消費するように Kafka コネクタを設定します："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"The `connector` attribute is required for all channels and specifies the connector to use.\n"
"You can omit this configuration if you have a single connector on your classpath, as Quarkus will automatically select the connector."
msgstr "`connector` 属性はすべてのチャネルで必須であり、使用するコネクタを指定します。クラスパスにコネクタが 1 つしかない場合は、この設定を省略できます。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Global channel attributes can be configured using the connector name:"
msgstr "グローバル・チャネル属性は、コネクタ名を使用して設定できます："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Connector-specific attributes are listed in connector documentation."
msgstr "コネクタ固有の属性は、コネクタのドキュメントに記載されています。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Channel wiring and Messaging patterns"
msgstr "チャネル配線とメッセージング・パターン"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"At startup time, Quarkus analyzes declared channels to wire them together and verify that all channels are connected.\n"
"Concretely, each channel creates a _reactive stream_ of messages connected to another channel's _reactive stream_ of messages.\n"
"Adhering to the reactive stream protocol, the back-pressure mechanism is enforced between channels, allowing to control application resource usage and not over-commit and overloading part of the system."
msgstr "起動時に、Quarkusは宣言されたチャネルを解析し、すべてのチャネルが接続されていることを確認します。具体的には、各チャネルは、別のチャネルのメッセージの _リアクティブストリームに_ 接続されたメッセージの _リアクティブストリームを_ 作成します。リアクティブストリームプロトコルに従うことで、チャネル間でバックプレッシャーメカニズムが実行され、アプリケーションリソースの使用を制御し、システムの一部にオーバーコミットやオーバーロードが発生しないようにします。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"On the flip side it is NOT possible to create new channels programmatically at runtime.\n"
"There are, however, many patterns that let you implement most, if not all, messaging and integration use cases:"
msgstr "反面、実行時にプログラムで新しいチャネルを作成することはできません。しかし、すべてではないにしても、メッセージングと統合のユースケースのほとんどを実装できるパターンがたくさんあります："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"Some messaging technologies allow consumers to subscribe to a set of topics or queues, and producers to send messages to a specific topic on message basis.\n"
"If you are sure you need to configure and create clients dynamically at runtime, you should consider using the low-level clients directly."
msgstr "メッセージング・テクノロジの中には、コンシューマが一連のトピックやキューをサブスクライブし、プロデューサがメッセージベースで特定のトピックにメッセージを送信できるものもあります。実行時にクライアントを動的に設定したり作成したりする必要がある場合は、低レベルクライアントを直接使用することを検討すべきです。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Internal Channels"
msgstr "内部チャンネル"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"In some use cases, it is convenient to use messaging patterns to transfer messages inside the same application.\n"
"When you don't connect a channel to a messaging backend, i.e. a connector, everything happens internally to the application,\n"
"and the streams are created by chaining methods together.\n"
"Each chain is still a reactive stream and enforces the back-pressure protocol."
msgstr "ユースケースによっては、同じアプリケーション内でメッセージを転送するためにメッセージングパターンを使うと便利です。チャネルをメッセージングバックエンド、つまりコネクタに接続しない場合、すべてがアプリケーション内部で発生し、ストリームはメソッドをチェーンして作成されます。各チェインはリアクティブストリームであり、バックプレッシャープロトコルを強制します。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"The framework verifies that the producer/consumer chain is complete,\n"
"meaning that if the application writes messages into an internal channel (using a method with only `@Outgoing`, or an `Emitter`),\n"
"it must also consume the messages from within the application (using a method with only `@Incoming` or using an unmanaged stream)."
msgstr "つまり、アプリケーションが内部チャネルにメッセージを書き込む場合（ `@Outgoing` のみのメソッドを使用するか、 `Emitter` ）、アプリケーション内からメッセージを消費する（ `@Incoming` のみのメソッドを使用するか、管理されていないストリームを使用する）必要があります。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Enable/Disable channels"
msgstr "チャンネルの有効/無効"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "All defined channels are enabled by default, but it is possible to disable a channel with the configuration:"
msgstr "定義されたすべてのチャンネルはデフォルトで有効になっていますが、コンフィギュレーションでチャンネルを無効にすることも可能です："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"This can be used alongside Quarkus build profiles to enable/disable channels based on some build-time condition, such as the the target environment.\n"
"You need to make sure of two things when disabling a channel:"
msgstr "Quarkusのビルドプロファイルと一緒に使用することで、ターゲット環境などのビルド時の条件に基づいて、チャンネルを有効/無効にすることができます。チャンネルを無効にする場合、2つのことを確認する必要があります："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "the disabled channel usage is located in a bean that can be filtered out at build time,"
msgstr "無効化されたチャネルの使用は、ビルド時にフィルタリングできるビーンにあります、"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "that without the channel, the remaining channels still work correctly."
msgstr "そのチャンネルがなくても、残りのチャンネルは正常に動作します。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Multiple Outgoings and `@Broadcast`"
msgstr "複数の支出と `@Broadcast`"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"By default, messages transmitted in a channel are only dispatched to a single consumer.\n"
"Having multiple consumers is considered an error and is reported at deployment time."
msgstr "デフォルトでは、チャネルで送信されたメッセージは単一のコンシューマにのみディスパッチされます。複数のコンシューマを持つことはエラーとみなされ、デプロイ時に報告されます。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"The `@Broadcast` annotation changes this behavior and indicates that messages transiting in the channel are dispatched to all the consumers.\n"
"`@Broadcast` must be used with the `@Outgoing` annotation:"
msgstr "`@Broadcast` アノテーションはこの動作を変更し、チャネルを通過するメッセー ジがすべてのコンシューマーにディスパッチされることを示します。 `@Broadcast` は `@Outgoing` アノテーションとともに使用する必要があります："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Similarly to `@Broadcast`, you can use `@Outgoing` annotation multiple times on the same method to indicate that the method produces messages to multiple channels:"
msgstr "`@Broadcast` と同様に、 `@Outgoing` アノテーションを同じメソッドで複数回使用すると、そのメソッドが複数のチャネルにメッセージを生成することを示すことができます："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Using Multiple Outgoings can be useful for implementing fan-out patterns, in which a single message is processed by multiple target channels."
msgstr "Multiple Outgoingsを使用すると、1つのメッセージが複数のターゲットチャネルで処理されるファンアウトパターンを実装するのに便利です。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "You can selectively dispatch messages to multiple outgoings by returning `Targeted` from the processing method:"
msgstr "処理メソッドから `Targeted` を返すことで、複数の送信先に選択的にメッセージをディスパッチすることができます："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Multiple Incomings and `@Merge`"
msgstr "複数の収入と `@Merge`"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"By default, a single producer can transmit messages in a channel.\n"
"Having multiple producers is considered erroneous and is reported at deployment time.\n"
"The `@Merge` annotation changes this behavior and indicates that a channel can have multiple producers.\n"
"`@Merge` must be used with the `@Incoming` annotation:"
msgstr "デフォルトでは、単一のプロデューサーがチャネルでメッセージを送信できます。複数のプロデューサーを持つことはエラーとみなされ、デプロイ時に報告されます。 `@Merge` アノテーションはこの動作を変更し、チャネルが複数のプロデューサーを持つことができることを示します。 `@Merge` は `@Incoming` アノテーションと一緒に使用する必要があります："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Similarly to `@Merge`, you can use `@Incoming` annotation multiple times on the same method to indicate that the method consumes messages from multiple channels:"
msgstr "`@Merge` と同様に、 `@Incoming` アノテーションを同じメソッドで複数回使用すると、そのメソッドが複数のチャネルからメッセージを消費することを示すことができます："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Stream Processing"
msgstr "ストリーム処理"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "In some advanced scenarios, you can manipulate directly the stream of messages instead of each individual message."
msgstr "いくつかの高度なシナリオでは、個々のメッセージではなく、メッセージのストリームを直接操作することができます。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Using link:{mutiny}[Mutiny APIs] in incoming and outgoing signatures allow you to process the stream of messages:"
msgstr "送受信シグネチャで link:{mutiny}[Mutiny APIを] 使用すると、メッセージのストリームを処理できます："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Execution Model"
msgstr "実行モデル"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"Quarkus Messaging sits on top of the xref:quarkus-reactive-architecture.adoc#engine[reactive engine] of Quarkus and leverages link:{eclipse-vertx}[Eclipse Vert.x] to dispatch messages for processing.\n"
"It supports three execution modes:"
msgstr "Quarkus Messagingは、Quarkusの xref:quarkus-reactive-architecture.adoc#engine[リアクティブエンジンの] 上に配置され、 link:{eclipse-vertx}[Eclipse Vert.xを] 活用して処理用のメッセージをディスパッチします。3つの実行モードをサポートしています："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"*Event-loop*, where messages are dispatched on the Vert.x I/O thread.\n"
"Remember that you should not perform blocking operations on the event loop."
msgstr "*イベントループでは* 、Vert.x I/O スレッドでメッセージがディスパッチされます。イベントループでブロッキング処理を実行しないように注意してください。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "*Worker-threads*, where messages are dispatched on a worker thread pool."
msgstr "*ワーカースレッド* 。ワーカースレッドプールでメッセージがディスパッチされます。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"*Virtual-threads*, where messages are dispatched on a virtual thread (requires Java 21+).\n"
"As virtual threads are not pooled, a new virtual thread is created for each message.\n"
"Please refer to the dedicated xref:messaging-virtual-threads.adoc[Quarkus Virtual Thread support] guide for more information."
msgstr "*仮想スレッドでは* 、メッセージは仮想スレッド上でディスパッチされます（Java 21以上が必要）。仮想スレッドはプールされないため、メッセージごとに新しい仮想スレッドが作成されます。詳細については、 xref:messaging-virtual-threads.adoc[Quarkus] 専用の xref:messaging-virtual-threads.adoc[仮想スレッドサポートガイドを] 参照してください。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"Quarkus chooses the default execution mode based on the method signature.\n"
"If the method signature is _synchronous_, messages are dispatched on *worker threads* otherwise it defaults to *event-loop*:"
msgstr "Quarkusは、メソッドのシグネチャに基づいてデフォルトの実行モードを選択します。メソッドのシグネチャが _synchronousの_ 場合、 *ワーカースレッドで* メッセージがディスパッチされます："

#: _versions/main/guides/messaging.adoc
msgid "Method signature"
msgstr "メソッドシグネチャ"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Default execution mode"
msgstr "デフォルトの実行モード"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"@Incoming(\"source\")\n"
"void process(String payload)"
msgstr "入力(\"ソース\") void process(String payload)"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Worker-threads"
msgstr "ワーカースレッド"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"@Incoming(\"source\")\n"
"Uni<Void> process(String payload)"
msgstr "@Incoming(\"source\") Uni<Void> process(文字列ペイロード)"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Event-loop"
msgstr "イベントループ"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"@Incoming(\"source\")\n"
"CompletionStage<Void> process(Message<String> message)"
msgstr "入力(\"source\") CompletionStage<Void> process(Message<String> message)"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"@Incoming(\"source\")\n"
"@Outgoing(\"sink\")\n"
"Multi<R> process(Multi<T> in)"
msgstr "受信(\"ソース\") @送信(\"シンク\") Multi<R> process(Multi<T> in)"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Stream-processing methods are executed at startup, then each message is dispatched on event loop."
msgstr "ストリーム処理メソッドは起動時に実行され、各メッセージはイベントループでディスパッチされます。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Fine-grained control over the execution model is possible using annotations:"
msgstr "アノテーションを使用することで、実行モデルをきめ細かく制御することができます："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"link:{rm_blocking_annotation}[`@Blocking`] will force the method to be executed on a worker thread pool.\n"
"The default pool of worker threads is shared between all channels.\n"
"Using `@Blocking(\"my-custom-pool\")` you can configure channels with a custom thread pool.\n"
"The configuration property `smallrye.messaging.worker.my-custom-pool.max-concurrency` specifies the maximum number of threads in the pool.\n"
"You can read more on the blocking processing in link:{rm_blocking_docs}[SmallRye Reactive Messaging documentation]."
msgstr "link:{rm_blocking_annotation}[@Blocking] を指定すると、メソッドはワーカースレッドプールで実行されるようになります。デフォルトのワーカースレッドプールはすべてのチャンネルで共有されます。 `@Blocking(\"my-custom-pool\")` を使用すると、カスタムスレッドプールでチャネルを設定できます。設定プロパティ `smallrye.messaging.worker.my-custom-pool.max-concurrency` は、プール内のスレッドの最大数を指定します。ブロッキング処理の詳細については、 link:{rm_blocking_docs}[SmallRye Reactive Messaging のドキュメントを] 参照してください。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "`@NonBlocking` will force the method to be executed on the event-loop thread."
msgstr "`@NonBlocking` はイベントループスレッドでメソッドを実行させます。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"`@RunOnVirtualThread` will force the method to be executed on a virtual thread.\n"
"To leverage the lightweight nature of virtual threads, the default maximum concurrency for methods annotated with `@RunOnVirtualThread` is 1024.\n"
"This can be changed by setting the `smallrye.messaging.worker.<virtual-thread>.max-concurrency` configuration property\n"
"or using together with the `@Blocking(\"my-custom-pool\")` annotation."
msgstr "`@RunOnVirtualThread` を指定すると、メソッドは強制的に仮想スレッドで実行されます。仮想スレッドの軽量性を活用するため、 アノテーションが付けられたメソッドのデフォルトの最大同時実行数は 1024 です。これは、 構成プロパティを設定するか、 アノテーションと併用することで変更できます。 `@RunOnVirtualThread` `smallrye.messaging.worker.<virtual-thread>.max-concurrency` `@Blocking(\"my-custom-pool\")`"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "The presence of `@Transactional` annotation implies blocking execution."
msgstr "`@Transactional` アノテーションの存在は、実行のブロッキングを意味します。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"In messaging applications, produced and consumed messages constitute an ordered stream of events,\n"
"either enforced by the broker (inside a topic or a queue)\n"
"or by the order of reception and emission in the application.\n"
"To preserve this order, Quarkus Messaging dispatches messages sequentially by default.\n"
"You can override this behavior by using `@Blocking(ordered = false)` or `@RunOnVirtualThread` annotation."
msgstr "メッセージングアプリケーションでは、生成および消費されるメッセージは、（トピックまたはキュー内の）ブローカによって強制されるか、アプリケーション内の受信および送信の順序によって、順序付けられたイベントのストリームを構成します。この順序を維持するために、Quarkus Messagingはデフォルトでメッセージを順番にディスパッチします。この動作をオーバーライドするには、 `@Blocking(ordered = false)` または `@RunOnVirtualThread` アノテーションを使用します。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Incoming Channel Concurrency"
msgstr "着信チャネルの同時並行性"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Some connectors support configuring the concurrency level of incoming channels."
msgstr "一部のコネクタは、受信チャネルの同時実行レベルの設定をサポートしています。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"This creates four copies of the incoming channel under the hood, wiring them to the same processing method.\n"
"Depending on the broker technology, this can be useful to increase the application's throughput by processing multiple messages concurrently\n"
"while still preserving the partial order of messages received in different copies.\n"
"This is the case, for example, for Kafka, where multiple consumers can consume different topic partitions."
msgstr "これは受信チャネルのコピーを 4 つ作成し、同じ処理メソッドに配線します。ブローカーの技術によっては、異なるコピーで受信したメッセージの部分的な順序を保持したまま複数のメッセージを同時に処理することで、アプリケーションのスループットを向上させるのに役立ちます。例えばKafkaの場合、複数のコンシューマーが異なるトピックパーティションを消費できます。"

#: _versions/main/guides/messaging.adoc
msgid "Health Checks"
msgstr "ヘルスチェック"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"Together with the Smallrye Health extension, Quarkus Messaging extensions provide health check support per channel.\n"
"The implementation of _startup_, _readiness_ and _liveness_ checks depends on the connector.\n"
"Some connectors allow configuring the health check behavior or disabling them completely or per channel."
msgstr "Quarkusのメッセージング拡張機能では、Smallrye Health拡張機能とともに、チャネルごとのヘルスチェックをサポートしています。 _起動_ チェック、 _準備完了_ チェック、 _有効性_ チェックの実装は、コネクタによって異なります。コネクタによっては、ヘルスチェックの動作を設定したり、完全に無効にしたり、チャネルごとに無効にしたりできます。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"Channel health checks can be disabled using `quarkus.messaging.health.<channel-name>.enabled` or per health check type,\n"
"ex. `quarkus.messaging.health.<channel-name>.liveness.enabled`."
msgstr "チャンネル・ヘルス・チェックは、 `quarkus.messaging.health.<channel-name>.enabled` またはヘルス・チェック・タイプ毎（例： `quarkus.messaging.health.<channel-name>.liveness.enabled` ）に無効にすることができます。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Setting the `quarkus.messaging.health.enabled` configuration property to `false` completely disables the messaging health checks."
msgstr "`quarkus.messaging.health.enabled` 構成プロパティを `false` に設定すると、メッセージング・ヘルス・チェックが完全に無効になります。"

#: _versions/main/guides/messaging.adoc
msgid "Observability"
msgstr "Observability"

#: _versions/main/guides/messaging.adoc
msgid "Micrometer Metrics"
msgstr "Micrometerメトリクス"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"Quarkus Messaging extensions provide simple but useful metrics to monitor the health of the messaging system.\n"
"The xref:telemetry-micrometer.adoc[Micrometer extension] exposes these metrics."
msgstr "Quarkusのメッセージング・エクステンションは、メッセージング・システムの健全性を監視するためのシンプルで有用なメトリクスを提供します。 xref:telemetry-micrometer.adoc[Micrometerエクステンションは] 、これらのメトリクスを公開します。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "The following metrics can be gathered per channel, identified with the `channel` tag:"
msgstr "`channel` タグで識別されるチャネルごとに、以下のメトリクスを収集できます："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "`quarkus.messaging.message.count` : The number of messages produced or received"
msgstr "`quarkus.messaging.message.count` 生成または受信されたメッセージの数"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "`quarkus.messaging.message.acks` : The number of messages processed successfully"
msgstr "`quarkus.messaging.message.acks` 正常に処理されたメッセージの数"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "`quarkus.messaging.message.failures` : The number of messages processed with failures"
msgstr "`quarkus.messaging.message.failures` 失敗したメッセージの数"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "`quarkus.messaging.message.duration` : The duration of the message processing"
msgstr "`quarkus.messaging.message.duration` メッセージの処理時間"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "For backwards compatibility reasons, channel metrics are not enabled by default and can be enabled with: `smallrye.messaging.observation.enabled=true`."
msgstr "後方互換性の理由から、チャネル・メトリクスはデフォルトでは有効になっていません： `smallrye.messaging.observation.enabled=true` ."

#: _versions/main/guides/messaging.adoc
msgid "OpenTelemetry Tracing"
msgstr "OpenTelemetry Tracing"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"Some Quarkus Messaging connectors integrate out-of-the-box with OpenTelemetry Tracing.\n"
"When the xref:opentelemetry.adoc[OpenTelemetry extension] is present, outgoing messages propagate the current tracing span.\n"
"On incoming channels, if a received message contains tracing information, the message processing inherits the message span as parent."
msgstr "一部のQuarkus Messagingコネクタは、OpenTelemetry Tracingとすぐに統合できます。 xref:opentelemetry.adoc[OpenTelemetry拡張機能が] ある場合、送信メッセージは現在のトレーススパンを伝播します。受信チャンネルにおいて、受信したメッセージにトレース情報が含まれている場合、メッセージ処理はメッセージスパンを親として継承します。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "You can disable tracing for a specific channel using the following configuration:"
msgstr "以下の設定を使用して、特定のチャネルのトレースを無効にすることができます："

#: _versions/main/guides/messaging.adoc
msgid "Testing"
msgstr "テスト"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Testing with Dev Services"
msgstr "開発サービスによるテスト"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"Most Quarkus Messaging extensions provide a Dev Service to simplify the development and testing of applications.\n"
"The Dev Service creates a broker instance configured to work out-of-the-box with the Quarkus Messaging extension."
msgstr "ほとんどのQuarkus Messaging拡張機能には、アプリケーションの開発とテストを簡素化するためのDev Serviceが用意されています。Dev Serviceは、Quarkus Messaging拡張機能ですぐに使用できるように設定されたブローカーインスタンスを作成します。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "During testing Quarkus creates a separate brok er instance to run the tests against it."
msgstr "テスト中、Quarkusは別のブローカーインスタンスを作成し、それに対してテストを実行します。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "You can read more about Dev Services in the xref:dev-services.adoc[Dev Services] guide, including a list of Dev Services provided by platform extensions."
msgstr "Dev Services の詳細については、プラットフォーム拡張機能によって提供される Dev Services のリストを含む、 xref:dev-services.adoc[Dev Services] ガイドを参照してください。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Testing with InMemoryConnector"
msgstr "InMemoryConnectorを使ったテスト"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"It can be useful to test the application without starting a broker.\n"
"To achieve this, you can _switch_ the channels managed by a connector to _in-memory_."
msgstr "ブローカーを起動せずにアプリケーションをテストすると便利です。これを実現するには、コネクタが管理するチャネルを _インメモリに_ _切り替えます_ 。"

#: _versions/main/guides/messaging.adoc
msgid "This approach only works for JVM tests. It cannot be used for native tests (because they do not support injection)."
msgstr "このアプローチは、JVM テストでのみ機能します。インジェクションには対応していないため、ネイティブテストには使用できません。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Let's say we want to test the following sample application:"
msgstr "次のサンプル・アプリケーションをテストしたいとしましょう："

#: _versions/main/guides/messaging.adoc
msgid "First, add the following test dependency to your application:"
msgstr "まず、以下のテスト依存関係をアプリケーションに追加します。"

#: _versions/main/guides/messaging.adoc
msgid "pom.xml"
msgstr "pom.xml"

#: _versions/main/guides/messaging.adoc
msgid "build.gradle"
msgstr "build.gradle"

#: _versions/main/guides/messaging.adoc
msgid "Then, create a Quarkus Test Resource as follows:"
msgstr "そして、以下のように Quarkus Test Resource を作成します。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Switch the incoming channel `words-in` (consumed messages) to in-memory."
msgstr "受信チャンネル `words-in` (消費メッセージ) をインメモリに切り替えます。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Switch the outgoing channel `words-out` (produced messages) to in-memory."
msgstr "発信チャネル `words-out` (生成されたメッセージ) をインメモリに切り替えます。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Switch the outgoing channel `uppercase` (processed messages) to in-memory."
msgstr "発信チャネル `uppercase` (処理済みメッセージ) をインメモリに切り替えます。"

#: _versions/main/guides/messaging.adoc
msgid "Builds and returns a `Map` containing all the properties required to configure the application to use in-memory channels."
msgstr "インメモリーチャネルを使用するためのアプリケーション設定に必要なすべてのプロパティを含む `Map` をビルドして返します。"

#: _versions/main/guides/messaging.adoc
msgid "When the test stops, clear the `InMemoryConnector` (discard all the received and sent messages)"
msgstr "テストが停止したら、`InMemoryConnector` をクリアします (受信したメッセージと送信したメッセージをすべて破棄してください)。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Create a `@QuarkusTest` using the test resource created above:"
msgstr "上記で作成したテストリソースを使用して `@QuarkusTest` を作成します："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Inject the in-memory connector in your test class, using the `@Connector` or `@Any` qualifier."
msgstr "`@Connector` または `@Any` 修飾子を使用して、テスト・クラスでインメモリ・コネクタを注入します。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Retrieve the outgoing channel (`words-out`) - the channel must have been switched to in-memory in the test resource."
msgstr "発信チャネルを取得 ( `words-out` ) - チャネルはテストリソースでインメモリに切り替えられている必要があります。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Retrieve the incoming channel (`words-in`)"
msgstr "受信チャンネルを取得 ( `words-in` )"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Retrieve the outgoing channel (`uppercase`)"
msgstr "発信チャンネルの取得 ( `uppercase` )"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Use the injected application bean to call `sendMessage` method to send a message using the emitter with the channel `words-out`."
msgstr "注入されたアプリケーションBeanを使用して `sendMessage` メソッドを呼び出し、チャネル `words-out` でエミッタを使用してメッセージを送信します。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Use the `received` method on `words-out` in-memory channel to check the message produced by the application."
msgstr "アプリケーションによって生成されたメッセージを確認するには、 `words-out` イン・メモリ・チャネルで `received` メソッドを使用します。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"Use the `send` mwthod on `words-in` in-memory channel to send a message.\n"
"The application will process this message and send a message to `uppercase` channel."
msgstr "`words-in` インメモリ・チャネルで `send` mwthod を使用してメッセージを送信します。アプリケーションはこのメッセージを処理し、 `uppercase` チャンネルにメッセージを送信します。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "Use the `received` method on `uppercase` channel to check the messages produced by the application."
msgstr "アプリケーションによって生成されたメッセージをチェックするには、 `uppercase` チャネルの `received` メソッドを使います。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"In-memory connector is solely intended for testing purposes.\n"
"There are some caveats to consider when using the in-memory connector:"
msgstr "インメモリ・コネクタはテストのみを目的としています。インメモリ・コネクタを使用する際には、いくつかの注意点があります："

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"The in-memory connector only transmits objects (payloads or configured messages) sent using the `InMemorySource#send` method.\n"
"Messages received by the application methods won't contain connector-specific metadata."
msgstr "インメモリ・コネクタは、 `InMemorySource#send` メソッドを使用して送信されたオブジェクト（ペイロードまたは構成済みメッセージ）のみを送信します。アプリケーション・メソッドで受信したメッセージには、コネクタ固有のメタデータは含まれません。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"By default, in-memory channels dispatch messages on the caller thread of the `InMemorySource#send` method, which would be the main thread in unit tests.\n"
"However, most of the other connectors handle context propagation dispatching messages on separate duplicated Vert.x contexts."
msgstr "デフォルトでは、インメモリチャンネルは、 `InMemorySource#send` メソッドの呼び出し元スレッド（ユニットテストではメインスレッド）にメッセージをディスパッチします。しかし、他のコネクタのほとんどは、Vert.x コンテキストを複製してメッセージをディスパッチするコンテキスト伝播を扱います。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "The `quarkus-test-vertx` dependency provides the `@io.quarkus.test.vertx.RunOnVertxContext` annotation, which when used on a test method, executes the test on a Vert.x context."
msgstr "`quarkus-test-vertx` 依存関係は、 `@io.quarkus.test.vertx.RunOnVertxContext` アノテーションを提供します。このアノテーションをテストメソッドで使用すると、Vert.x コンテキストでテストが実行されます。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"If your tests are dependent on context propagation, you can configure the in-memory connector channels with `run-on-vertx-context` attribute to dispatch events, including messages and acknowledgements, on a Vert.x context.\n"
"Alternatively you can switch this behaviour using the `InMemorySource#runOnVertxContext` method."
msgstr "テストがコンテキストの伝搬に依存している場合は、 `run-on-vertx-context` 属性を持つインメモリ・コネクタ・チャネルを設定して、Vert.x コンテキスト上でメッセージや確認応答などのイベントをディスパッチすることができます。また、 `InMemorySource#runOnVertxContext` メソッドを使用して、この動作を切り替えることもできます。"

#: _versions/main/guides/messaging.adoc
msgid "Going further"
msgstr "さらに詳しく"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid "This guide shows the general principles of Quarkus Messaging extensions."
msgstr "このガイドでは、Quarkusメッセージング拡張機能の一般的な原則について説明します。"

#: _versions/main/guides/messaging.adoc
#, fuzzy
msgid ""
"If you want to go further, you can check the link:{rm_doc}[SmallRye Reactive Messaging] documentation,\n"
"which has in-depth documentation for each of these concepts and more."
msgstr "さらに詳しく知りたい場合は、 link:{rm_doc}[SmallRye Reactive Messagingの] ドキュメントを参照してください。"

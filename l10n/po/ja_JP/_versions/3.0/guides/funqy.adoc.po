msgid ""
msgstr ""
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: doc-l10n-kit"

#. This guide is maintained in the main Quarkus repository
#. and pull requests should be submitted there:
#. https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
#. type: Title =
#: upstream/_versions/3.0/guides/funqy.adoc:6
#, no-wrap
msgid "Funqy"
msgstr "Funqy"

#. type: Plain text
#: upstream/_versions/3.0/guides/funqy.adoc:15
msgid "Quarkus Funqy is part of Quarkus's serverless strategy and aims to provide a portable Java API to write functions deployable to various FaaS environments like AWS Lambda, Azure Functions, Google Cloud Functions, Knative, and Knative Events (Cloud Events).  It is also usable as a standalone service."
msgstr "Quarkus Funqy は、Quarkus のサーバーレス戦略の一部であり、AWS Lambda、Azure Functions、Google Cloud Functions、Knative、Knative Events（Cloud Events）などの様々な FaaS 環境にデプロイ可能なファンクションを書くためのポータブルな Java API を提供することを目的としています。また、スタンドアロンのサービスとしても使用することができます。"

#. type: Plain text
#: upstream/_versions/3.0/guides/funqy.adoc:21
msgid "Because Funqy is an abstraction that spans multiple different cloud/function providers and protocols it has to be a very simple API and thus, might not have all the features you are used to in other remoting abstractions.  A nice side effect though is that Funqy is as optimized and as small as possible.  This means that because Funqy sacrifices a little on flexibility, you'll get a framework that has little to no overhead."
msgstr "Funqy は複数の異なるクラウド、ファンクションプロバイダーやプロトコルに跨った抽象化を提供するため、その API は非常にシンプルである必要があり、ユーザーが使い慣れている他のリモーティング抽象化で提供される機能を全て備えているとは限りません。一方で、Funqy は可能な限り最適化され、かつ小さいという良い副次的効果があります。これは、Funqy は柔軟性を少し犠牲にしている分、オーバーヘッドが非常に少ないフレームワークであることを意味しています。"

#. type: Title ==
#: upstream/_versions/3.0/guides/funqy.adoc:22
#, no-wrap
msgid "Funqy Basics"
msgstr "Funqy の基礎"

#. type: Plain text
#: upstream/_versions/3.0/guides/funqy.adoc:26
msgid "The Funqy API is simple.  Annotate a method with `@Funq`.  This method may only have one optional input parameter and may or may not return a response."
msgstr "Funqy API はシンプルです。メソッドに `@Funq` をアノテーションします。このメソッドはオプションの入力パラメータを1つだけ持つことができ、レスポンスを返しても返さなくても問題ありません。"

#. type: delimited block -
#: upstream/_versions/3.0/guides/funqy.adoc:30
#: upstream/_versions/3.0/guides/funqy.adoc:100
#: upstream/_versions/3.0/guides/funqy.adoc:120
#, no-wrap
msgid "import io.quarkus.funqy.Funq;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/3.0/guides/funqy.adoc:37
#, no-wrap
msgid ""
"public class GreetingFunction {\n"
"    @Funq\n"
"    public String greet(String name) {\n"
"       return \"Hello \" + name;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: upstream/_versions/3.0/guides/funqy.adoc:43
msgid "Java classes can also be used as input and output and must follow the Java bean convention and have a default constructor.  The Java type that is declared as the parameter or return type is the type that will be expected by the Funqy runtime.  Funqy does type introspection at build time to speed up boot time, so any derived types will not be noticed by the Funqy marshalling layer at runtime."
msgstr "デフォルトのコンストラクタを持ち、Java Bean の規約に従った Java クラスは、入力と出力に使用できます。パラメータや戻り値の型として宣言された Java のクラスは、Funqy のランタイムが期待する型となります。Funqy は起動時間を短縮するためにビルド時にクラスのイントロスペクションを行うため、派生クラスは実行時に Funqy のマーシャリングレイヤーに意識されることはありません。"

#. type: Plain text
#: upstream/_versions/3.0/guides/funqy.adoc:45
msgid "Here's an example of using a POJO as input and output types."
msgstr "以下に、POJO を入出力の型として使用した例をご紹介します。"

#. type: delimited block -
#: upstream/_versions/3.0/guides/funqy.adoc:51
#, no-wrap
msgid ""
"public class GreetingFunction {\n"
"    public static class Friend {\n"
"        String name;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/3.0/guides/funqy.adoc:55
#, no-wrap
msgid ""
"        public String getName() { return name; }\n"
"        public void setName(String name) { this.name = name; }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/3.0/guides/funqy.adoc:58
#, no-wrap
msgid ""
"    public static class Greeting {\n"
"        String msg;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/3.0/guides/funqy.adoc:61
#, no-wrap
msgid ""
"        public Greeting() {}\n"
"        public Greeting(String msg) { this.msg = msg }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/3.0/guides/funqy.adoc:65
#, no-wrap
msgid ""
"        public String getMessage() { return msg; }\n"
"        public void setMessage(String msg) { this.msg = msg; }\n"
"    }\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/3.0/guides/funqy.adoc:71
#, no-wrap
msgid ""
"    @Funq\n"
"    public Greeting greet(Friend friend) {\n"
"       return new Greeting(\"Hello \" + friend.getName());\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/3.0/guides/funqy.adoc:73
#, no-wrap
msgid "Async Reactive Types"
msgstr "非同期リアクティブ型"

#. type: Plain text
#: upstream/_versions/3.0/guides/funqy.adoc:77
msgid "Funqy supports the https://smallrye.io/smallrye-mutiny[Smallrye Mutiny] `Uni` reactive type as a return type.  The only requirement is that the `Uni` must fill out the generic type."
msgstr "Funqy は戻り値の型として link:https://smallrye.io/smallrye-mutiny[Smallrye Mutiny] `Uni` リアクティブ型をサポートしています。 `Uni` がジェネリクス型として記述される必要があります。"

#. type: delimited block -
#: upstream/_versions/3.0/guides/funqy.adoc:82
#, no-wrap
msgid ""
"import io.quarkus.funqy.Funq;\n"
"import io.smallrye.mutiny.Uni;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/3.0/guides/funqy.adoc:84
#: upstream/_versions/3.0/guides/funqy.adoc:102
#: upstream/_versions/3.0/guides/funqy.adoc:159
#, no-wrap
msgid "public class GreetingFunction {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/3.0/guides/funqy.adoc:90
#, no-wrap
msgid ""
"    @Funq\n"
"    public Uni<Greeting> reactiveGreeting(String name) {\n"
"       ...\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/3.0/guides/funqy.adoc:92
#, no-wrap
msgid "Function Names"
msgstr "ファンクション名"

#. type: Plain text
#: upstream/_versions/3.0/guides/funqy.adoc:96
msgid "The function name defaults to the method name and is case-sensitive.  If you want your function referenced by a different name, parameterize the `@Funq` annotation as follows:"
msgstr "ファンクション名のデフォルト値はメソッド名で、大文字と小文字は区別されます。ファンクションを別の名前で参照したい場合は、以下のように `@Funq` アノテーションにパラメータを記述します。"

#. type: delimited block -
#: upstream/_versions/3.0/guides/funqy.adoc:108
#, no-wrap
msgid ""
"    @Funq(\"HelloWorld\")\n"
"    public String greet(String name) {\n"
"       return \"Hello \" + name;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/3.0/guides/funqy.adoc:110
#, no-wrap
msgid "Funqy DI"
msgstr "Funqy DI"

#. type: Plain text
#: upstream/_versions/3.0/guides/funqy.adoc:114
msgid "Each Funqy Java class is a Quarkus Arc component and supports dependency injection through CDI or Spring DI.  Spring DI requires including the `quarkus-spring-di` dependency in your build."
msgstr "それぞれの Funqy Java クラスは Quarkus Arc コンポーネントであり、CDI または Spring DI による依存性注入をサポートしています。Spring DI では、ビルドに `quarkus-spring-di` の依存関係を含める必要があります。"

#. type: Plain text
#: upstream/_versions/3.0/guides/funqy.adoc:116
msgid "The default object lifecycle for a Funqy class is `@Dependent`."
msgstr "Funqy クラスのデフォルトのオブジェクトライフサイクルは `@Dependent` となります。"

#. type: delimited block -
#: upstream/_versions/3.0/guides/funqy.adoc:123
#, no-wrap
msgid ""
"import jakarta.inject.Inject;\n"
"import jakarta.enterprise.context.ApplicationScoped;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/3.0/guides/funqy.adoc:126
#, no-wrap
msgid ""
"@ApplicationScoped\n"
"public class GreetingFunction {\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/3.0/guides/funqy.adoc:129
#, no-wrap
msgid ""
"    @Inject\n"
"    GreetingService service;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/3.0/guides/funqy.adoc:137
#, no-wrap
msgid ""
"    @Funq\n"
"    public Greeting greet(Friend friend) {\n"
"        Greeting greeting = new Greeting();\n"
"        greeting.setMessage(service.greet(friend.getName()));\n"
"        return greeting;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/3.0/guides/funqy.adoc:139
#, no-wrap
msgid "Context injection"
msgstr "コンテキストの注入"

#. type: Plain text
#: upstream/_versions/3.0/guides/funqy.adoc:145
msgid "The Funqy API will usually not allow you to inject or use abstractions that are specific to a protocol (i.e. HTTP) or function API (i.e. AWS Lambda).  There are exceptions to the rule though, and you may be able to inject contextual information that is specific to the environment you are deploying in."
msgstr "通常、 Funqy API はプロトコル (例: HTTP ) やファンクション API (例: AWS Lambda) に固有の抽象化を注入したり、使用したりすることはできません。例外もあり、デプロイ先の環境に応じたコンテキスト情報を注入できる場合もあります。"

#. type: Plain text
#: upstream/_versions/3.0/guides/funqy.adoc:147
msgid "We do not recommend injecting contextual information specific to a runtime.  Keep your functions portable."
msgstr "ランタイムに固有のコンテキスト情報を注入することは推奨されません。 ファンクションを移植性の高いものにしてください。"

#. type: Plain text
#: upstream/_versions/3.0/guides/funqy.adoc:151
msgid "Contextual information is injected via the `@Context` annotation which can be used on a function parameter or a class field.  A good example is the `io.quarkus.funqy.knative.events.CloudEvent` interface that comes with our Funqy Knative Cloud Events integration:"
msgstr "コンテキスト情報は、ファンクションのパラメータやクラスのフィールドに使用できる `@Context` アノテーションを介して注入されます。例として、 Funqy Knative Cloud Events に搭載されている `io.quarkus.funqy.knative.events.CloudEvent` インターフェースがあります。"

#. type: delimited block -
#: upstream/_versions/3.0/guides/funqy.adoc:157
#, no-wrap
msgid ""
"import io.quarkus.funqy.Funq;\n"
"import io.quarkus.funqy.Context;\n"
"import io.quarkus.funqy.knative.events.CloudEvent;\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/3.0/guides/funqy.adoc:163
#, no-wrap
msgid ""
"    @Funq\n"
"    public Greeting greet(Friend friend, @Context CloudEvent eventInfo) {\n"
"        System.out.println(\"Received greeting request from: \" eventInfo.getSource());\n"
msgstr ""

#. type: delimited block -
#: upstream/_versions/3.0/guides/funqy.adoc:169
#, no-wrap
msgid ""
"        Greeting greeting = new Greeting();\n"
"        greeting.setMessage(\"Hello \" + friend.getName()));\n"
"        return greeting;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ==
#: upstream/_versions/3.0/guides/funqy.adoc:171
#, no-wrap
msgid "Should I Use Funqy?"
msgstr "Funqy を使うべきか？"

#. type: Plain text
#: upstream/_versions/3.0/guides/funqy.adoc:190
msgid "The purpose of Funqy is to allow you to write cross-provider functions so that you can move off of your current function provider if, for instance, they start charging you a lot more for their service.  Another reason you might not want to use Funqy is if you need access specific APIs of the target function environment.  For example, developers often want access to the AWS Context on Lambda.  In this case, we tell them they may be better off using the xref:amazon-lambda.adoc[Quarkus Amazon Lambda] integration instead."
msgstr "Funqy の目的は、プロバイダーを跨いだファンクションを書けるようにすることであり、例えば、現在のファンクションプロバイダーの利用料金が上昇してしまった場合に、そこから移動できるようにすることです。対象のファンクション実行環境の特定の API にアクセスする必要がある場合は、Funqy を使わない理由となり得ます。よくある例としては、開発者が Lambda で AWS Context にアクセスしたい場合です。この場合は、代わりに xref:amazon-lambda.adoc[Quarkus Amazon Lambda] による統合を使用した方が良い場合があります。"
